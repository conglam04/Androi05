<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/activity/Lich/App.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/activity/Lich/App.java" />
              <option name="originalContent" value="package com.example.todolist.Ui.activity.Lich;&#10;&#10;import android.app.Application;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.os.Build;&#10;&#10;// Lớp này chạy một lần duy nhất khi ứng dụng khởi động&#10;public class App extends Application {&#10;&#10;    public static final String CHANNEL_ID = &quot;REMINDER_CHANNEL_1&quot;;&#10;&#10;    @Override&#10;    public void onCreate() {&#10;        super.onCreate();&#10;        createNotificationChannel();&#10;    }&#10;&#10;    private void createNotificationChannel() {&#10;        // Chỉ tạo kênh trên API 26 (Android 8.0) trở lên&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationManager notificationManager = getSystemService(NotificationManager.class);&#10;            &#10;            // Channel 1: For Lich/AlarmReceiver&#10;            CharSequence name = &quot;Kênh Nhắc nhở Nhiệm vụ&quot;;&#10;            String description = &quot;Kênh để hiển thị thông báo nhắc nhở nhiệm vụ&quot;;&#10;            int importance = NotificationManager.IMPORTANCE_HIGH; // Ưu tiên cao&#10;&#10;            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);&#10;            channel.setDescription(description);&#10;            channel.enableVibration(true);&#10;            channel.enableLights(true);&#10;            notificationManager.createNotificationChannel(channel);&#10;            &#10;            // Channel 2: For task reminders (NotificationHelper)&#10;            NotificationChannel taskReminderChannel = new NotificationChannel(&#10;                    &quot;task_reminder_channel&quot;,&#10;                    &quot;Task Reminders&quot;,&#10;                    NotificationManager.IMPORTANCE_HIGH&#10;            );&#10;            taskReminderChannel.setDescription(&quot;Notifications for task reminders&quot;);&#10;            taskReminderChannel.enableVibration(true);&#10;            taskReminderChannel.enableLights(true);&#10;            notificationManager.createNotificationChannel(taskReminderChannel);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.todolist.Ui.activity.Lich;&#13;&#10;&#13;&#10;import android.app.Application;&#13;&#10;import android.app.NotificationChannel;&#13;&#10;import android.app.NotificationManager;&#13;&#10;import android.os.Build;&#13;&#10;&#13;&#10;// Lớp này chạy một lần duy nhất khi ứng dụng khởi động&#13;&#10;public class App extends Application {&#13;&#10;&#13;&#10;    public static final String CHANNEL_ID = &quot;REMINDER_CHANNEL_1&quot;;&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void onCreate() {&#13;&#10;        super.onCreate();&#13;&#10;        createNotificationChannel();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void createNotificationChannel() {&#10;        // Chỉ tạo kênh trên API 26 (Android 8.0) trở lên&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationManager notificationManager = getSystemService(NotificationManager.class);&#10;            &#10;            // Channel 1: For Lich/AlarmReceiver&#10;            CharSequence name = &quot;Kênh Nhắc nhở Nhiệm vụ&quot;;&#10;            String description = &quot;Kênh để hiển thị thông báo nhắc nhở nhiệm vụ&quot;;&#10;            int importance = NotificationManager.IMPORTANCE_HIGH; // Ưu tiên cao&#10;&#10;            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);&#10;            channel.setDescription(description);&#10;            channel.enableVibration(true);&#10;            channel.enableLights(true);&#10;            notificationManager.createNotificationChannel(channel);&#10;            &#10;            // Channel 2: For task reminders (NotificationHelper)&#10;            NotificationChannel taskReminderChannel = new NotificationChannel(&#10;                    &quot;task_reminder_channel&quot;,&#10;                    &quot;Task Reminders&quot;,&#10;                    NotificationManager.IMPORTANCE_HIGH&#10;            );&#10;            taskReminderChannel.setDescription(&quot;Notifications for task reminders&quot;);&#10;            taskReminderChannel.enableVibration(true);&#10;            taskReminderChannel.enableLights(true);&#10;            notificationManager.createNotificationChannel(taskReminderChannel);&#10;        }&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/maintaskfragement/AddTaskBottomSheet.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/maintaskfragement/AddTaskBottomSheet.java" />
              <option name="originalContent" value="package com.example.todolist.Ui.maintaskfragement;&#10;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.EditText;&#10;import android.widget.ImageButton;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.appcompat.app.AlertDialog;&#10;import androidx.lifecycle.ViewModelProvider;&#10;&#10;import com.example.todolist.Data.entity.Category;&#10;import com.example.todolist.Data.entity.RecurrenceRule;&#10;import com.example.todolist.Data.entity.Task;&#10;import com.example.todolist.R;&#10;import com.example.todolist.Ui.viewmodel.TasksViewModel;&#10;import com.example.todolist.utils.ReminderScheduler;&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment;&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Calendar;&#10;import java.util.List;&#10;&#10;public class AddTaskBottomSheet extends BottomSheetDialogFragment {&#10;&#10;    private EditText editTaskTitle;&#10;    private TextView textCategoryLabel;&#10;    private ImageButton btnSetTime;&#10;    private ImageButton btnSetReminder;&#10;    private ImageButton btnSetRepeat;&#10;    private ImageButton btnAddSubtask;&#10;    private ImageButton btnSetTag;&#10;    private ImageButton btnIdea;&#10;    private FloatingActionButton btnSaveTask;&#10;&#10;    private TasksViewModel viewModel;&#10;    private List&lt;Category&gt; categories = new ArrayList&lt;&gt;();&#10;    private Long selectedDueDate = null;&#10;    private Long selectedReminderDate = null;&#10;    private int selectedCategoryId = -1;  // Changed from long to int to match Task entity&#10;    private String selectedCategoryName = &quot;không có thẻ loại&quot;;&#10;    private RecurrenceRule selectedRecurrenceRule;&#10;&#10;    public static AddTaskBottomSheet newInstance() {&#10;        return new AddTaskBottomSheet();&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,&#10;                             @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.bottom_sheet_add_task, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(view, savedInstanceState);&#10;&#10;        // Initialize ViewModel&#10;        viewModel = new ViewModelProvider(requireActivity()).get(TasksViewModel.class);&#10;&#10;        // Initialize views&#10;        initViews(view);&#10;&#10;        // Setup listeners&#10;        setupListeners();&#10;&#10;        // Load categories&#10;        loadCategories();&#10;&#10;        // Auto focus on edit text&#10;        editTaskTitle.requestFocus();&#10;    }&#10;&#10;    private void initViews(View view) {&#10;        editTaskTitle = view.findViewById(R.id.editTaskTitle);&#10;        textCategoryLabel = view.findViewById(R.id.textCategoryLabel);&#10;        btnSetTime = view.findViewById(R.id.btnSetTime);&#10;        btnSetReminder = view.findViewById(R.id.btnSetReminder);&#10;        btnSetRepeat = view.findViewById(R.id.btnSetRepeat);&#10;        btnAddSubtask = view.findViewById(R.id.btnAddSubtask);&#10;        btnSetTag = view.findViewById(R.id.btnSetTag);&#10;        btnIdea = view.findViewById(R.id.btnIdea);&#10;        btnSaveTask = view.findViewById(R.id.btnSaveTask);&#10;    }&#10;&#10;    private void setupListeners() {&#10;        textCategoryLabel.setOnClickListener(v -&gt; showCategoryPicker());&#10;        btnSetTime.setOnClickListener(v -&gt; showDateTimePicker());&#10;        btnSetReminder.setOnClickListener(v -&gt; showReminderTimePicker());&#10;        btnSetRepeat.setOnClickListener(v -&gt;&#10;        {&#10;            RecurrenceBottomSheet bottomSheet = RecurrenceBottomSheet.newInstance(selectedRecurrenceRule);&#10;            bottomSheet.setOnRecurrenceSelectedListener(rule -&gt; {&#10;                selectedRecurrenceRule = rule;&#10;            });&#10;            bottomSheet.show(getParentFragmentManager(), &quot;RecurrenceBottomSheet&quot;);&#10;        });&#10;        btnAddSubtask.setOnClickListener(v -&gt; showAddSubtaskDialog());&#10;        btnSetTag.setOnClickListener(v -&gt; showTagDialog());&#10;        btnIdea.setOnClickListener(v -&gt; toggleIdeaMode());&#10;        btnSaveTask.setOnClickListener(v -&gt; saveTask());&#10;    }&#10;&#10;    private void loadCategories() {&#10;        viewModel.getAllCategories().observe(getViewLifecycleOwner(), categoryList -&gt; {&#10;            if (categoryList != null &amp;&amp; !categoryList.isEmpty()) {&#10;                categories = categoryList;&#10;&#10;                // Set default category from current filter&#10;                viewModel.getSelectedCategoryId().observe(getViewLifecycleOwner(), selectedId -&gt; {&#10;                    if (selectedId != null &amp;&amp; selectedId != -1) {&#10;                        for (Category category : categories) {&#10;                            if (category.getCategoryId() == selectedId) {&#10;                                selectedCategoryId = category.getCategoryId();&#10;                                selectedCategoryName = category.getName();&#10;                                textCategoryLabel.setText(selectedCategoryName);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                });&#10;            }&#10;        });&#10;    }&#10;    private void showDateTimePicker()&#10;    {&#10;        DateTimePickerBottomSheet picker = DateTimePickerBottomSheet.newInstance(&#10;                selectedDueDate,&#10;                selectedReminderDate,&#10;                selectedRecurrenceRule&#10;        );&#10;        picker.setOnDateTimeSelectedListener((timestamp, reminderTimestamp, repeatRule) -&gt; {&#10;            if (timestamp != -1) {&#10;                selectedDueDate = timestamp;&#10;                String s = android.text.format.DateFormat.getDateFormat(requireContext()).format(timestamp);&#10;                Toast.makeText(requireContext(), &quot;Đã chọn: &quot; + s, Toast.LENGTH_SHORT).show();&#10;                btnSetTime.setColorFilter(getResources().getColor(R.color.primary, null));&#10;            } else {&#10;                selectedDueDate = null;&#10;                Toast.makeText(requireContext(), &quot;Bỏ chọn ngày&quot;, Toast.LENGTH_SHORT).show();&#10;                btnSetTime.clearColorFilter();&#10;            }&#10;&#10;            // Update reminder timestamp&#10;            if (reminderTimestamp != null) {&#10;                selectedReminderDate = reminderTimestamp;&#10;                btnSetReminder.setColorFilter(getResources().getColor(R.color.primary, null));&#10;            } else {&#10;                selectedReminderDate = null;&#10;                btnSetReminder.clearColorFilter();&#10;            }&#10;&#10;            // Update recurrence rule&#10;            if (repeatRule != null) {&#10;                selectedRecurrenceRule = repeatRule;&#10;                btnSetRepeat.setColorFilter(getResources().getColor(R.color.primary, null));&#10;            } else {&#10;                selectedRecurrenceRule = null;&#10;                btnSetRepeat.clearColorFilter();&#10;            }&#10;        });&#10;        picker.show(getParentFragmentManager(), &quot;DateTimePicker&quot;);&#10;    }&#10;    private void showCategoryPicker() {&#10;        if (categories.isEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Chưa có danh mục&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        String[] categoryNames = new String[categories.size()];&#10;        for (int i = 0; i &lt; categories.size(); i++) {&#10;            categoryNames[i] = categories.get(i).getName();&#10;        }&#10;&#10;        AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());&#10;        builder.setTitle(&quot;Chọn danh mục&quot;);&#10;        builder.setItems(categoryNames, (dialog, which) -&gt; {&#10;            selectedCategoryId = categories.get(which).getCategoryId();&#10;            selectedCategoryName = categories.get(which).getName();&#10;            textCategoryLabel.setText(selectedCategoryName);&#10;        });&#10;        builder.show();&#10;    }&#10;&#10;    private void showReminderTimePicker() {&#10;        // Get base date from selectedDueDate or current date&#10;        Calendar baseDateCal = Calendar.getInstance();&#10;        if (selectedDueDate != null) {&#10;            baseDateCal.setTimeInMillis(selectedDueDate);&#10;        }&#10;&#10;        // Get current hour/minute from existing reminder or now&#10;        int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);&#10;        int minute = Calendar.getInstance().get(Calendar.MINUTE);&#10;        if (selectedReminderDate != null) {&#10;            Calendar reminderCal = Calendar.getInstance();&#10;            reminderCal.setTimeInMillis(selectedReminderDate);&#10;            hour = reminderCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = reminderCal.get(Calendar.MINUTE);&#10;        }&#10;&#10;        // Use MaterialTimePicker (like in Lich package)&#10;        com.google.android.material.timepicker.MaterialTimePicker picker =&#10;                new com.google.android.material.timepicker.MaterialTimePicker.Builder()&#10;                .setTimeFormat(com.google.android.material.timepicker.TimeFormat.CLOCK_24H)&#10;                .setHour(hour)&#10;                .setMinute(minute)&#10;                .setTitleText(&quot;Đặt giờ nhắc nhở&quot;)&#10;                .setInputMode(com.google.android.material.timepicker.MaterialTimePicker.INPUT_MODE_CLOCK)&#10;                .build();&#10;&#10;        picker.addOnPositiveButtonClickListener(v -&gt; {&#10;            int h = picker.getHour();&#10;            int m = picker.getMinute();&#10;&#10;            // Create reminder time based on base date&#10;            Calendar reminderCal = (Calendar) baseDateCal.clone();&#10;            reminderCal.set(Calendar.HOUR_OF_DAY, h);&#10;            reminderCal.set(Calendar.MINUTE, m);&#10;            reminderCal.set(Calendar.SECOND, 0);&#10;            reminderCal.set(Calendar.MILLISECOND, 0);&#10;&#10;            long reminderTime = reminderCal.getTimeInMillis();&#10;&#10;            // Validate: Reminder must be in future&#10;            if (reminderTime &lt;= System.currentTimeMillis()) {&#10;                Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải ở tương lai!&quot;,&#10;                        Toast.LENGTH_LONG).show();&#10;                return;&#10;            }&#10;&#10;            // Validate: Reminder must be before due time (if due date has specific time)&#10;            if (selectedDueDate != null) {&#10;                Calendar dueCal = Calendar.getInstance();&#10;                dueCal.setTimeInMillis(selectedDueDate);&#10;                // Only check if due date has specific time (not end of day)&#10;                if (dueCal.get(Calendar.HOUR_OF_DAY) != 23 || dueCal.get(Calendar.MINUTE) != 59) {&#10;                    if (reminderTime &gt;= selectedDueDate) {&#10;                        Toast.makeText(requireContext(),&#10;                                &quot;Thời gian nhắc nhở phải trước giờ deadline!&quot;,&#10;                                Toast.LENGTH_LONG).show();&#10;                        return;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Save reminder time&#10;            selectedReminderDate = reminderTime;&#10;            btnSetReminder.setColorFilter(getResources().getColor(R.color.primary, null));&#10;&#10;            String timeStr = String.format(java.util.Locale.getDefault(), &quot;%02d:%02d&quot;, h, m);&#10;            Toast.makeText(requireContext(),&#10;                    &quot;Đã đặt nhắc nhở lúc &quot; + timeStr,&#10;                    Toast.LENGTH_SHORT).show();&#10;        });&#10;&#10;        picker.show(getParentFragmentManager(), &quot;ReminderPicker&quot;);&#10;    }&#10;&#10;&#10;    private void showAddSubtaskDialog() {&#10;        Toast.makeText(requireContext(),&#10;                &quot;Tính năng công việc con đang phát triển&quot;,&#10;                Toast.LENGTH_SHORT).show();&#10;    }&#10;&#10;    private void showTagDialog() {&#10;        Toast.makeText(requireContext(),&#10;                &quot;Tính năng thẻ tag đang phát triển&quot;,&#10;                Toast.LENGTH_SHORT).show();&#10;    }&#10;&#10;    private void toggleIdeaMode() {&#10;        Toast.makeText(requireContext(),&#10;                &quot;Chế độ ý tưởng&quot;,&#10;                Toast.LENGTH_SHORT).show();&#10;    }&#10;&#10;    private void saveTask() {&#10;        String title = editTaskTitle.getText().toString().trim();&#10;&#10;        if (title.isEmpty()) {&#10;            Toast.makeText(requireContext(),&#10;                    &quot;Vui lòng nhập tên nhiệm vụ&quot;,&#10;                    Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        // Ensure we have a valid category before proceeding&#10;        if (selectedCategoryId == -1) {&#10;            if (!categories.isEmpty()) {&#10;                selectedCategoryId = categories.get(0).getCategoryId();&#10;                selectedCategoryName = categories.get(0).getName();&#10;            } else {&#10;                Toast.makeText(requireContext(),&#10;                        &quot;Đang tải danh mục, vui lòng thử lại&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                return;&#10;            }&#10;        }&#10;&#10;        // Set default due date if not set&#10;        if (selectedDueDate == null) {&#10;            // Set default due date: today at 23:59 (end of day)&#10;            Calendar cal = Calendar.getInstance();&#10;            cal.set(Calendar.HOUR_OF_DAY, 23);&#10;            cal.set(Calendar.MINUTE, 59);&#10;            cal.set(Calendar.SECOND, 59);&#10;            cal.set(Calendar.MILLISECOND, 999);&#10;            selectedDueDate = cal.getTimeInMillis();&#10;        }&#10;&#10;        // Create new task with proper Integer categoryId&#10;        Task newTask = new Task(title, &quot;&quot;, selectedCategoryId);&#10;        &#10;        // Explicitly set categoryId again to ensure it's saved&#10;        newTask.setCategoryId(selectedCategoryId);&#10;        &#10;        // Debug log&#10;        android.util.Log.d(&quot;AddTaskBottomSheet&quot;, &quot;Saving task with categoryId: &quot; + selectedCategoryId + &#10;                &quot; (categoryName: &quot; + selectedCategoryName + &quot;)&quot;);&#10;        android.util.Log.d(&quot;AddTaskBottomSheet&quot;, &quot;Task object categoryId: &quot; + newTask.getCategoryId());&#10;        &#10;        // Set due date and reminder date to the task&#10;        newTask.setDueDate(selectedDueDate);&#10;        if (selectedReminderDate != null) {&#10;            newTask.setReminderDate(selectedReminderDate);&#10;        }&#10;&#10;        // QUAN TRỌNG: Insert task TRƯỚC, sau đó mới save recurrence rule&#10;        long taskId = viewModel.insertTask(newTask);&#10;&#10;        if (taskId &gt; 0) {&#10;            // Set taskId cho newTask&#10;            newTask.setTaskId((int) taskId);&#10;&#10;            // Bây giờ mới save recurrence rule&#10;            if (selectedRecurrenceRule != null &amp;&amp; !selectedRecurrenceRule.getPattern().equals(&quot;NONE&quot;)) {&#10;                selectedRecurrenceRule.setTaskId(taskId); // Set taskId vào rule&#10;                viewModel.saveRecurrenceRule(newTask, selectedRecurrenceRule);&#10;            }&#10;&#10;            // Schedule reminder notification if user set a reminder time&#10;            if (selectedReminderDate != null &amp;&amp; selectedReminderDate &gt; System.currentTimeMillis()) {&#10;                ReminderScheduler.scheduleReminder(&#10;                        requireContext(),&#10;                        taskId,&#10;                        title,&#10;                        &quot;&quot;, // description - can be empty for now&#10;                        selectedReminderDate&#10;                );&#10;                Toast.makeText(requireContext(),&#10;                        &quot;Đã thêm nhiệm vụ và đặt nhắc nhở&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;            } else {&#10;                Toast.makeText(requireContext(),&#10;                        &quot;Đã thêm nhiệm vụ&quot; +&#10;                                (newTask.isRecurring() ? &quot; (lặp lại)&quot; : &quot;&quot;),&#10;                        Toast.LENGTH_SHORT).show();&#10;            }&#10;&#10;            dismiss();&#10;        } else {&#10;            Toast.makeText(requireContext(),&#10;                    &quot;Lỗi khi thêm nhiệm vụ&quot;,&#10;                    Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public int getTheme() {&#10;        return R.style.BottomSheetDialogTheme;&#10;    }&#10;&#10;    @Override&#10;    public void onStart() {&#10;        super.onStart();&#10;        View dialogView = getDialog() == null ? null : getDialog().findViewById(com.google.android.material.R.id.design_bottom_sheet);&#10;        if (dialogView != null) {&#10;            dialogView.getLayoutParams().height = ViewGroup.LayoutParams.WRAP_CONTENT;&#10;            dialogView.requestLayout();&#10;            com.google.android.material.bottomsheet.BottomSheetBehavior&lt;View&gt; behavior = com.google.android.material.bottomsheet.BottomSheetBehavior.from(dialogView);&#10;            behavior.setFitToContents(true);&#10;            behavior.setSkipCollapsed(true);&#10;            behavior.setState(com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_EXPANDED);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.todolist.Ui.maintaskfragement;&#10;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.EditText;&#10;import android.widget.ImageButton;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;import androidx.appcompat.app.AlertDialog;&#10;import androidx.lifecycle.ViewModelProvider;&#10;&#10;import com.example.todolist.Data.entity.Category;&#10;import com.example.todolist.Data.entity.RecurrenceRule;&#10;import com.example.todolist.Data.entity.Task;&#10;import com.example.todolist.R;&#10;import com.example.todolist.Ui.viewmodel.TasksViewModel;&#10;import com.example.todolist.utils.ReminderScheduler;&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment;&#10;import com.google.android.material.floatingactionbutton.FloatingActionButton;&#10;&#10;import java.util.ArrayList;&#10;import java.util.Calendar;&#10;import java.util.List;&#10;&#10;public class AddTaskBottomSheet extends BottomSheetDialogFragment {&#10;&#10;    private EditText editTaskTitle;&#10;    private TextView textCategoryLabel;&#10;    private ImageButton btnSetTime;&#10;    private ImageButton btnSetReminder;&#10;    private ImageButton btnSetRepeat;&#10;    private ImageButton btnAddSubtask;&#10;    private ImageButton btnSetTag;&#10;    private ImageButton btnIdea;&#10;    private FloatingActionButton btnSaveTask;&#10;&#10;    private TasksViewModel viewModel;&#10;    private List&lt;Category&gt; categories = new ArrayList&lt;&gt;();&#10;    private Long selectedDueDate = null;&#10;    private Long selectedReminderDate = null;&#10;    private int selectedCategoryId = -1;  // Changed from long to int to match Task entity&#10;    private String selectedCategoryName = &quot;không có thẻ loại&quot;;&#10;    private RecurrenceRule selectedRecurrenceRule;&#10;&#10;    public static AddTaskBottomSheet newInstance() {&#10;        return new AddTaskBottomSheet();&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,&#10;                             @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.bottom_sheet_add_task, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        super.onViewCreated(view, savedInstanceState);&#10;&#10;        // Initialize ViewModel&#10;        viewModel = new ViewModelProvider(requireActivity()).get(TasksViewModel.class);&#10;&#10;        // Initialize views&#10;        initViews(view);&#10;&#10;        // Setup listeners&#10;        setupListeners();&#10;&#10;        // Load categories&#10;        loadCategories();&#10;&#10;        // Auto focus on edit text&#10;        editTaskTitle.requestFocus();&#10;    }&#10;&#10;    private void initViews(View view) {&#10;        editTaskTitle = view.findViewById(R.id.editTaskTitle);&#10;        textCategoryLabel = view.findViewById(R.id.textCategoryLabel);&#10;        btnSetTime = view.findViewById(R.id.btnSetTime);&#10;        btnSetReminder = view.findViewById(R.id.btnSetReminder);&#10;        btnSetRepeat = view.findViewById(R.id.btnSetRepeat);&#10;        btnAddSubtask = view.findViewById(R.id.btnAddSubtask);&#10;        btnSetTag = view.findViewById(R.id.btnSetTag);&#10;        btnIdea = view.findViewById(R.id.btnIdea);&#10;        btnSaveTask = view.findViewById(R.id.btnSaveTask);&#10;    }&#10;&#10;    private void setupListeners() {&#10;        textCategoryLabel.setOnClickListener(v -&gt; showCategoryPicker());&#10;        btnSetTime.setOnClickListener(v -&gt; showDateTimePicker());&#10;        btnSetReminder.setOnClickListener(v -&gt; showReminderTimePicker());&#10;        btnSetRepeat.setOnClickListener(v -&gt;&#10;        {&#10;            RecurrenceBottomSheet bottomSheet = RecurrenceBottomSheet.newInstance(selectedRecurrenceRule);&#10;            bottomSheet.setOnRecurrenceSelectedListener(rule -&gt; {&#10;                selectedRecurrenceRule = rule;&#10;            });&#10;            bottomSheet.show(getParentFragmentManager(), &quot;RecurrenceBottomSheet&quot;);&#10;        });&#10;        btnAddSubtask.setOnClickListener(v -&gt; showAddSubtaskDialog());&#10;        btnSetTag.setOnClickListener(v -&gt; showTagDialog());&#10;        btnIdea.setOnClickListener(v -&gt; toggleIdeaMode());&#10;        btnSaveTask.setOnClickListener(v -&gt; saveTask());&#10;    }&#10;&#10;    private void loadCategories() {&#10;        viewModel.getAllCategories().observe(getViewLifecycleOwner(), categoryList -&gt; {&#10;            if (categoryList != null &amp;&amp; !categoryList.isEmpty()) {&#10;                categories = categoryList;&#10;&#10;                // Set default category from current filter&#10;                viewModel.getSelectedCategoryId().observe(getViewLifecycleOwner(), selectedId -&gt; {&#10;                    if (selectedId != null &amp;&amp; selectedId != -1) {&#10;                        for (Category category : categories) {&#10;                            if (category.getCategoryId() == selectedId) {&#10;                                selectedCategoryId = category.getCategoryId();&#10;                                selectedCategoryName = category.getName();&#10;                                textCategoryLabel.setText(selectedCategoryName);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                });&#10;            }&#10;        });&#10;    }&#10;    private void showDateTimePicker()&#10;    {&#10;        DateTimePickerBottomSheet picker = DateTimePickerBottomSheet.newInstance(&#10;                selectedDueDate,&#10;                selectedReminderDate,&#10;                selectedRecurrenceRule&#10;        );&#10;        picker.setOnDateTimeSelectedListener((timestamp, reminderTimestamp, repeatRule) -&gt; {&#10;            if (timestamp != -1) {&#10;                selectedDueDate = timestamp;&#10;                String s = android.text.format.DateFormat.getDateFormat(requireContext()).format(timestamp);&#10;                Toast.makeText(requireContext(), &quot;Đã chọn: &quot; + s, Toast.LENGTH_SHORT).show();&#10;                btnSetTime.setColorFilter(getResources().getColor(R.color.primary, null));&#10;            } else {&#10;                selectedDueDate = null;&#10;                Toast.makeText(requireContext(), &quot;Bỏ chọn ngày&quot;, Toast.LENGTH_SHORT).show();&#10;                btnSetTime.clearColorFilter();&#10;            }&#10;&#10;            // Update reminder timestamp&#10;            if (reminderTimestamp != null) {&#10;                selectedReminderDate = reminderTimestamp;&#10;                btnSetReminder.setColorFilter(getResources().getColor(R.color.primary, null));&#10;            } else {&#10;                selectedReminderDate = null;&#10;                btnSetReminder.clearColorFilter();&#10;            }&#10;&#10;            // Update recurrence rule&#10;            if (repeatRule != null) {&#10;                selectedRecurrenceRule = repeatRule;&#10;                btnSetRepeat.setColorFilter(getResources().getColor(R.color.primary, null));&#10;            } else {&#10;                selectedRecurrenceRule = null;&#10;                btnSetRepeat.clearColorFilter();&#10;            }&#10;        });&#10;        picker.show(getParentFragmentManager(), &quot;DateTimePicker&quot;);&#10;    }&#10;    private void showCategoryPicker() {&#10;        if (categories.isEmpty()) {&#10;            Toast.makeText(requireContext(), &quot;Chưa có danh mục&quot;, Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        String[] categoryNames = new String[categories.size()];&#10;        for (int i = 0; i &lt; categories.size(); i++) {&#10;            categoryNames[i] = categories.get(i).getName();&#10;        }&#10;&#10;        AlertDialog.Builder builder = new AlertDialog.Builder(requireContext());&#10;        builder.setTitle(&quot;Chọn danh mục&quot;);&#10;        builder.setItems(categoryNames, (dialog, which) -&gt; {&#10;            selectedCategoryId = categories.get(which).getCategoryId();&#10;            selectedCategoryName = categories.get(which).getName();&#10;            textCategoryLabel.setText(selectedCategoryName);&#10;        });&#10;        builder.show();&#10;    }&#10;&#10;    private void showReminderTimePicker() {&#10;        // Get base date from selectedDueDate or current date&#10;        Calendar baseDateCal = Calendar.getInstance();&#10;        if (selectedDueDate != null) {&#10;            baseDateCal.setTimeInMillis(selectedDueDate);&#10;        }&#10;&#10;        // Get current hour/minute from existing reminder or now&#10;        int hour = Calendar.getInstance().get(Calendar.HOUR_OF_DAY);&#10;        int minute = Calendar.getInstance().get(Calendar.MINUTE);&#10;        if (selectedReminderDate != null) {&#10;            Calendar reminderCal = Calendar.getInstance();&#10;            reminderCal.setTimeInMillis(selectedReminderDate);&#10;            hour = reminderCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = reminderCal.get(Calendar.MINUTE);&#10;        }&#10;&#10;        // Use MaterialTimePicker (like in Lich package)&#10;        com.google.android.material.timepicker.MaterialTimePicker picker =&#10;                new com.google.android.material.timepicker.MaterialTimePicker.Builder()&#10;                .setTimeFormat(com.google.android.material.timepicker.TimeFormat.CLOCK_24H)&#10;                .setHour(hour)&#10;                .setMinute(minute)&#10;                .setTitleText(&quot;Đặt giờ nhắc nhở&quot;)&#10;                .setInputMode(com.google.android.material.timepicker.MaterialTimePicker.INPUT_MODE_CLOCK)&#10;                .build();&#10;&#10;        picker.addOnPositiveButtonClickListener(v -&gt; {&#10;            int h = picker.getHour();&#10;            int m = picker.getMinute();&#10;&#10;            // Create reminder time based on base date&#10;            Calendar reminderCal = (Calendar) baseDateCal.clone();&#10;            reminderCal.set(Calendar.HOUR_OF_DAY, h);&#10;            reminderCal.set(Calendar.MINUTE, m);&#10;            reminderCal.set(Calendar.SECOND, 0);&#10;            reminderCal.set(Calendar.MILLISECOND, 0);&#10;&#10;            long reminderTime = reminderCal.getTimeInMillis();&#10;&#10;            // Validate: Reminder must be in future&#10;            if (reminderTime &lt;= System.currentTimeMillis()) {&#10;                Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải ở tương lai!&quot;,&#10;                        Toast.LENGTH_LONG).show();&#10;                return;&#10;            }&#10;&#10;            // Validate: Reminder must be before due time (if due date has specific time)&#10;            if (selectedDueDate != null) {&#10;                Calendar dueCal = Calendar.getInstance();&#10;                dueCal.setTimeInMillis(selectedDueDate);&#10;                // Only check if due date has specific time (not end of day)&#10;                if (dueCal.get(Calendar.HOUR_OF_DAY) != 23 || dueCal.get(Calendar.MINUTE) != 59) {&#10;                    if (reminderTime &gt;= selectedDueDate) {&#10;                        Toast.makeText(requireContext(),&#10;                                &quot;Thời gian nhắc nhở phải trước giờ deadline!&quot;,&#10;                                Toast.LENGTH_LONG).show();&#10;                        return;&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Save reminder time&#10;            selectedReminderDate = reminderTime;&#10;            btnSetReminder.setColorFilter(getResources().getColor(R.color.primary, null));&#10;&#10;            String timeStr = String.format(java.util.Locale.getDefault(), &quot;%02d:%02d&quot;, h, m);&#10;            Toast.makeText(requireContext(),&#10;                    &quot;Đã đặt nhắc nhở lúc &quot; + timeStr,&#10;                    Toast.LENGTH_SHORT).show();&#10;        });&#10;&#10;        picker.show(getParentFragmentManager(), &quot;ReminderPicker&quot;);&#10;    }&#10;&#10;&#10;    private void showAddSubtaskDialog() {&#10;        Toast.makeText(requireContext(),&#10;                &quot;Tính năng công việc con đang phát triển&quot;,&#10;                Toast.LENGTH_SHORT).show();&#10;    }&#10;&#10;    private void showTagDialog() {&#10;        Toast.makeText(requireContext(),&#10;                &quot;Tính năng thẻ tag đang phát triển&quot;,&#10;                Toast.LENGTH_SHORT).show();&#10;    }&#10;&#10;    private void toggleIdeaMode() {&#10;        Toast.makeText(requireContext(),&#10;                &quot;Chế độ ý tưởng&quot;,&#10;                Toast.LENGTH_SHORT).show();&#10;    }&#10;&#10;    private void saveTask() {&#10;        String title = editTaskTitle.getText().toString().trim();&#10;&#10;        if (title.isEmpty()) {&#10;            Toast.makeText(requireContext(),&#10;                    &quot;Vui lòng nhập tên nhiệm vụ&quot;,&#10;                    Toast.LENGTH_SHORT).show();&#10;            return;&#10;        }&#10;&#10;        // Ensure we have a valid category before proceeding&#10;        if (selectedCategoryId == -1) {&#10;            if (!categories.isEmpty()) {&#10;                selectedCategoryId = categories.get(0).getCategoryId();&#10;                selectedCategoryName = categories.get(0).getName();&#10;            } else {&#10;                Toast.makeText(requireContext(),&#10;                        &quot;Đang tải danh mục, vui lòng thử lại&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                return;&#10;            }&#10;        }&#10;&#10;        // Set default due date if not set&#10;        if (selectedDueDate == null) {&#10;            // Set default due date: today at 23:59 (end of day)&#10;            Calendar cal = Calendar.getInstance();&#10;            cal.set(Calendar.HOUR_OF_DAY, 23);&#10;            cal.set(Calendar.MINUTE, 59);&#10;            cal.set(Calendar.SECOND, 59);&#10;            cal.set(Calendar.MILLISECOND, 999);&#10;            selectedDueDate = cal.getTimeInMillis();&#10;        }&#10;&#10;        // Create new task with proper Integer categoryId&#10;        Task newTask = new Task(title, &quot;&quot;, selectedCategoryId);&#10;        &#10;        // Explicitly set categoryId again to ensure it's saved&#10;        newTask.setCategoryId(selectedCategoryId);&#10;        &#10;        // Debug log&#10;        android.util.Log.d(&quot;AddTaskBottomSheet&quot;, &quot;Saving task with categoryId: &quot; + selectedCategoryId + &#10;                &quot; (categoryName: &quot; + selectedCategoryName + &quot;)&quot;);&#10;        android.util.Log.d(&quot;AddTaskBottomSheet&quot;, &quot;Task object categoryId: &quot; + newTask.getCategoryId());&#10;        &#10;        // Set due date and reminder date to the task&#10;        newTask.setDueDate(selectedDueDate);&#10;        if (selectedReminderDate != null) {&#10;            newTask.setReminderDate(selectedReminderDate);&#10;        }&#10;&#10;        // QUAN TRỌNG: Insert task TRƯỚC, sau đó mới save recurrence rule&#10;        long taskId = viewModel.insertTask(newTask);&#10;&#10;        if (taskId &gt; 0) {&#10;            // Set taskId cho newTask&#10;            newTask.setTaskId((int) taskId);&#10;&#10;            // Bây giờ mới save recurrence rule&#10;            if (selectedRecurrenceRule != null &amp;&amp; !selectedRecurrenceRule.getPattern().equals(&quot;NONE&quot;)) {&#10;                selectedRecurrenceRule.setTaskId(taskId); // Set taskId vào rule&#10;                viewModel.saveRecurrenceRule(newTask, selectedRecurrenceRule);&#10;            }&#10;&#10;            // Schedule reminder notification if user set a reminder time&#10;            if (selectedReminderDate != null &amp;&amp; selectedReminderDate &gt; System.currentTimeMillis()) {&#10;                ReminderScheduler.scheduleReminder(&#10;                        requireContext(),&#10;                        taskId,&#10;                        title,&#10;                        &quot;&quot;, // description - can be empty for now&#10;                        selectedReminderDate&#10;                );&#10;                Toast.makeText(requireContext(),&#10;                        &quot;Đã thêm nhiệm vụ và đặt nhắc nhở&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;            } else {&#10;                Toast.makeText(requireContext(),&#10;                        &quot;Đã thêm nhiệm vụ&quot; +&#10;                                (newTask.isRecurring() ? &quot; (lặp lại)&quot; : &quot;&quot;),&#10;                        Toast.LENGTH_SHORT).show();&#10;            }&#10;&#10;            dismiss();&#10;        } else {&#10;            Toast.makeText(requireContext(),&#10;                    &quot;Lỗi khi thêm nhiệm vụ&quot;,&#10;                    Toast.LENGTH_SHORT).show();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public int getTheme() {&#10;        return R.style.BottomSheetDialogTheme;&#10;    }&#10;&#10;    @Override&#10;    public void onStart() {&#10;        super.onStart();&#10;        View dialogView = getDialog() == null ? null : getDialog().findViewById(com.google.android.material.R.id.design_bottom_sheet);&#10;        if (dialogView != null) {&#10;            dialogView.getLayoutParams().height = ViewGroup.LayoutParams.WRAP_CONTENT;&#10;            dialogView.requestLayout();&#10;            com.google.android.material.bottomsheet.BottomSheetBehavior&lt;View&gt; behavior = com.google.android.material.bottomsheet.BottomSheetBehavior.from(dialogView);&#10;            behavior.setFitToContents(true);&#10;            behavior.setSkipCollapsed(true);&#10;            behavior.setState(com.google.android.material.bottomsheet.BottomSheetBehavior.STATE_EXPANDED);&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/maintaskfragement/DateTimePickerBottomSheet.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/maintaskfragement/DateTimePickerBottomSheet.java" />
              <option name="originalContent" value="package com.example.todolist.Ui.maintaskfragement;&#10;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.CalendarView;&#10;import android.widget.ImageButton;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;&#10;import com.example.todolist.Data.entity.RecurrenceRule;&#10;import com.example.todolist.R;&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment;&#10;&#10;import java.text.DateFormat;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Locale;&#10;&#10;public class DateTimePickerBottomSheet extends BottomSheetDialogFragment {&#10;&#10;    public interface OnDateTimeSelectedListener {&#10;        void onDateTimeSelected(long timestamp, Long reminderTimestamp, RecurrenceRule repeatRule);&#10;    }&#10;&#10;    private OnDateTimeSelectedListener listener;&#10;&#10;    private CalendarView calendarView;&#10;    private TextView valueTime, valueReminder, valueRepeat;&#10;    private ImageButton btnClose, btnOk;&#10;    private long selectedDateMillis = -1;&#10;    private Long selectedTimeMillis = null;&#10;    private Long selectedReminderMillis = null;&#10;    private RecurrenceRule selectedRecurrenceRule;&#10;&#10;    private final DateFormat timeFormat = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault());&#10;    private final DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault());&#10;&#10;    public DateTimePickerBottomSheet() {&#10;        // Required empty public constructor&#10;    }&#10;&#10;    public static DateTimePickerBottomSheet newInstance(Long initialDueDate, Long initialReminderDate, RecurrenceRule recurrenceRule) {&#10;        DateTimePickerBottomSheet fragment = new DateTimePickerBottomSheet();&#10;        Bundle args = new Bundle();&#10;        if (initialDueDate != null) {&#10;            args.putLong(&quot;dueDate&quot;, initialDueDate);&#10;        }&#10;        if (initialReminderDate != null) {&#10;            args.putLong(&quot;reminderDate&quot;, initialReminderDate);&#10;        }&#10;        if (recurrenceRule != null) {&#10;            args.putSerializable(&quot;recurrenceRule&quot;, recurrenceRule);&#10;        }&#10;        fragment.setArguments(args);&#10;        return fragment;&#10;    }&#10;&#10;    public void setOnDateTimeSelectedListener(OnDateTimeSelectedListener l) {&#10;        this.listener = l;&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,&#10;                             @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.bottom_sheet_date_time_picker, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        calendarView = view.findViewById(R.id.calendarView);&#10;        valueTime = view.findViewById(R.id.value_time);&#10;        valueReminder = view.findViewById(R.id.value_reminder);&#10;        valueRepeat = view.findViewById(R.id.value_repeat);&#10;        btnClose = view.findViewById(R.id.btnClose);&#10;        btnOk = view.findViewById(R.id.btnOk);&#10;//        btnIdea = view.findViewById(R.id.findViewById);&#10;&#10;        // Initialize from arguments if provided&#10;        if (getArguments() != null) {&#10;            if (getArguments().containsKey(&quot;dueDate&quot;)) {&#10;                selectedDateMillis = getArguments().getLong(&quot;dueDate&quot;);&#10;                Calendar dueCal = Calendar.getInstance();&#10;                dueCal.setTimeInMillis(selectedDateMillis);&#10;                selectedTimeMillis = selectedDateMillis;&#10;                calendarView.setDate(selectedDateMillis, false, false);&#10;            } else {&#10;                selectedDateMillis = calendarView.getDate();&#10;            }&#10;&#10;            if (getArguments().containsKey(&quot;reminderDate&quot;)) {&#10;                selectedReminderMillis = getArguments().getLong(&quot;reminderDate&quot;);&#10;            }&#10;&#10;            if (getArguments().containsKey(&quot;recurrenceRule&quot;)) {&#10;                selectedRecurrenceRule = (RecurrenceRule) getArguments().getSerializable(&quot;recurrenceRule&quot;);&#10;            }&#10;        } else {&#10;            // init selectedDate = today&#10;            selectedDateMillis = calendarView.getDate();&#10;        }&#10;&#10;        calendarView.setOnDateChangeListener((view1, year, month, dayOfMonth) -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.set(year, month, dayOfMonth, 0, 0, 0);&#10;            c.set(Calendar.MILLISECOND, 0);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;        });&#10;&#10;        // chips quick actions (today, tomorrow, 3 days...) - using IDs from layout&#10;        View chipToday = view.findViewById(R.id.chip_today);&#10;        View chipTomorrow = view.findViewById(R.id.chip_tomorrow);&#10;        View chip3Days = view.findViewById(R.id.chip_3days);&#10;        View chipNone = view.findViewById(R.id.chip_none);&#10;        View chipSunday = view.findViewById(R.id.chip_sunday);&#10;&#10;        chipToday.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipToday, chipTomorrow, chip3Days, chipNone, chipSunday);&#10;        });&#10;&#10;        chipTomorrow.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.add(Calendar.DAY_OF_YEAR, 1);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipTomorrow, chipToday, chip3Days, chipNone, chipSunday);&#10;        });&#10;&#10;        chip3Days.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.add(Calendar.DAY_OF_YEAR, 3);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chip3Days, chipToday, chipTomorrow, chipNone, chipSunday);&#10;        });&#10;&#10;        chipNone.setOnClickListener(v -&gt; {&#10;            selectedDateMillis = -1;&#10;            // you may visually clear selection; CalendarView default cannot clear selection easily&#10;            Toast.makeText(requireContext(), &quot;Bỏ chọn ngày&quot;, Toast.LENGTH_SHORT).show();&#10;            updateChipSelection(chipNone, chipToday, chipTomorrow, chip3Days, chipSunday);&#10;        });&#10;&#10;        chipSunday.setOnClickListener(v -&gt; {&#10;            // set to next Sunday&#10;            Calendar c = Calendar.getInstance();&#10;            while (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {&#10;                c.add(Calendar.DAY_OF_YEAR, 1);&#10;            }&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipSunday, chipToday, chipTomorrow, chip3Days, chipNone);&#10;        });&#10;&#10;        // time row click -&gt; time picker&#10;        View rowTime = view.findViewById(R.id.row_time);&#10;        rowTime.setOnClickListener(v -&gt; showTimePicker(true));&#10;&#10;        View rowReminder = view.findViewById(R.id.row_reminder);&#10;        rowReminder.setOnClickListener(v -&gt; showTimePicker(false));&#10;&#10;        View rowRepeat = view.findViewById(R.id.row_repeat);&#10;        rowRepeat.setOnClickListener(v -&gt; showRepeatDialog());&#10;&#10;        // close / ok&#10;        btnClose.setOnClickListener(v -&gt; dismiss());&#10;        btnOk.setOnClickListener(v -&gt; {&#10;            long resultTimestamp = -1;&#10;            Long resultReminderTimestamp = null;&#10;&#10;            if (selectedDateMillis != -1) {&#10;                if (selectedTimeMillis != null) {&#10;                    // merge date + time&#10;                    Calendar dateCal = Calendar.getInstance();&#10;                    dateCal.setTimeInMillis(selectedDateMillis);&#10;&#10;                    Calendar timeCal = Calendar.getInstance();&#10;                    timeCal.setTimeInMillis(selectedTimeMillis);&#10;&#10;                    dateCal.set(Calendar.HOUR_OF_DAY, timeCal.get(Calendar.HOUR_OF_DAY));&#10;                    dateCal.set(Calendar.MINUTE, timeCal.get(Calendar.MINUTE));&#10;                    dateCal.set(Calendar.SECOND, 0);&#10;                    resultTimestamp = dateCal.getTimeInMillis();&#10;                } else {&#10;                    // date only -&gt; default time to end of day (23:59:59)&#10;                    Calendar dateCal = Calendar.getInstance();&#10;                    dateCal.setTimeInMillis(selectedDateMillis);&#10;                    dateCal.set(Calendar.HOUR_OF_DAY, 23);&#10;                    dateCal.set(Calendar.MINUTE, 59);&#10;                    dateCal.set(Calendar.SECOND, 59);&#10;                    dateCal.set(Calendar.MILLISECOND, 999);&#10;                    resultTimestamp = dateCal.getTimeInMillis();&#10;                }&#10;            }&#10;&#10;            if (selectedReminderMillis != null &amp;&amp; selectedDateMillis != -1) {&#10;                Calendar reminderCal = Calendar.getInstance();&#10;                reminderCal.setTimeInMillis(selectedDateMillis);&#10;&#10;                Calendar reminderTimeCal = Calendar.getInstance();&#10;                reminderTimeCal.setTimeInMillis(selectedReminderMillis);&#10;&#10;                reminderCal.set(Calendar.HOUR_OF_DAY, reminderTimeCal.get(Calendar.HOUR_OF_DAY));&#10;                reminderCal.set(Calendar.MINUTE, reminderTimeCal.get(Calendar.MINUTE));&#10;                reminderCal.set(Calendar.SECOND, 0);&#10;                resultReminderTimestamp = reminderCal.getTimeInMillis();&#10;&#10;                // Validate: Reminder time must be before due time (if same day)&#10;                if (resultTimestamp != -1 &amp;&amp; resultReminderTimestamp &gt;= resultTimestamp) {&#10;                    Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải trước giờ deadline!&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                    return; // Don't close dialog&#10;                }&#10;&#10;                // Validate: Reminder time must be in future&#10;                if (resultReminderTimestamp &lt;= System.currentTimeMillis()) {&#10;                    Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải ở tương lai!&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                    return; // Don't close dialog&#10;                }&#10;            }&#10;&#10;            if (listener != null) {&#10;                listener.onDateTimeSelected(resultTimestamp, resultReminderTimestamp, selectedRecurrenceRule);&#10;            }&#10;            dismiss();&#10;        });&#10;&#10;        // initial UI values&#10;        updateUI();&#10;    }&#10;&#10;    private void updateUI() {&#10;        if (selectedTimeMillis != null) {&#10;            valueTime.setText(timeFormat.format(selectedTimeMillis));&#10;        } else {&#10;            valueTime.setText(&quot;Không&quot;);&#10;        }&#10;&#10;        if (selectedReminderMillis != null) {&#10;            valueReminder.setText(timeFormat.format(selectedReminderMillis));&#10;        } else {&#10;            valueReminder.setText(&quot;Không&quot;);&#10;        }&#10;&#10;        valueRepeat.setText(selectedRecurrenceRule != null ? selectedRecurrenceRule.getPattern() : &quot;Không&quot;);&#10;    }&#10;&#10;    private void showTimePicker(boolean isDueTime) {&#10;        // Get current time or existing selected time&#10;        Calendar currentCal = Calendar.getInstance();&#10;        int hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;        int minute = currentCal.get(Calendar.MINUTE);&#10;&#10;        // If editing existing time, use that value&#10;        if (isDueTime &amp;&amp; selectedTimeMillis != null) {&#10;            currentCal.setTimeInMillis(selectedTimeMillis);&#10;            hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = currentCal.get(Calendar.MINUTE);&#10;        } else if (!isDueTime &amp;&amp; selectedReminderMillis != null) {&#10;            currentCal.setTimeInMillis(selectedReminderMillis);&#10;            hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = currentCal.get(Calendar.MINUTE);&#10;        }&#10;&#10;        // Use MaterialTimePicker (like in Lich package)&#10;        String title = isDueTime ? &quot;Đặt giờ deadline&quot; : &quot;Đặt giờ nhắc nhở&quot;;&#10;&#10;        com.google.android.material.timepicker.MaterialTimePicker picker =&#10;                new com.google.android.material.timepicker.MaterialTimePicker.Builder()&#10;                .setTimeFormat(com.google.android.material.timepicker.TimeFormat.CLOCK_24H)&#10;                .setHour(hour)&#10;                .setMinute(minute)&#10;                .setTitleText(title)&#10;                .setInputMode(com.google.android.material.timepicker.MaterialTimePicker.INPUT_MODE_CLOCK)&#10;                .build();&#10;&#10;        picker.addOnPositiveButtonClickListener(v -&gt; {&#10;            int h = picker.getHour();&#10;            int m = picker.getMinute();&#10;&#10;            // Create time calendar&#10;            Calendar sel = Calendar.getInstance();&#10;            sel.set(Calendar.HOUR_OF_DAY, h);&#10;            sel.set(Calendar.MINUTE, m);&#10;            sel.set(Calendar.SECOND, 0);&#10;            sel.set(Calendar.MILLISECOND, 0);&#10;&#10;            if (isDueTime) {&#10;                selectedTimeMillis = sel.getTimeInMillis();&#10;                valueTime.setText(timeFormat.format(selectedTimeMillis));&#10;            } else {&#10;                selectedReminderMillis = sel.getTimeInMillis();&#10;                valueReminder.setText(timeFormat.format(selectedReminderMillis));&#10;            }&#10;        });&#10;&#10;        picker.show(getParentFragmentManager(), isDueTime ? &quot;TimePickerDue&quot; : &quot;TimePickerReminder&quot;);&#10;    }&#10;&#10;    private void showRepeatDialog() {&#10;        RecurrenceBottomSheet bottomSheet = RecurrenceBottomSheet.newInstance(selectedRecurrenceRule);&#10;        bottomSheet.setOnRecurrenceSelectedListener(rule -&gt; {&#10;            selectedRecurrenceRule = rule;&#10;            updateUI();&#10;        });&#10;        bottomSheet.show(getParentFragmentManager(), &quot;RecurrenceBottomSheet&quot;);&#10;    }&#10;&#10;    private void updateChipSelection(View selectedChip, View... otherChips) {&#10;        // Set selected chip to blue background and white text&#10;        selectedChip.setBackgroundResource(R.drawable.bg_chip_selected);&#10;        if (selectedChip instanceof TextView) {&#10;            ((TextView) selectedChip).setTextColor(getResources().getColor(R.color.white, null));&#10;        }&#10;&#10;        // Set other chips to gray background and primary text color&#10;        for (View chip : otherChips) {&#10;            chip.setBackgroundResource(R.drawable.bg_chip_gray);&#10;            if (chip instanceof TextView) {&#10;                ((TextView) chip).setTextColor(getResources().getColor(R.color.text_primary, null));&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.todolist.Ui.maintaskfragement;&#10;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.CalendarView;&#10;import android.widget.ImageButton;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;&#10;import com.example.todolist.Data.entity.RecurrenceRule;&#10;import com.example.todolist.R;&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment;&#10;&#10;import java.text.DateFormat;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Locale;&#10;&#10;public class DateTimePickerBottomSheet extends BottomSheetDialogFragment {&#10;&#10;    public interface OnDateTimeSelectedListener {&#10;        void onDateTimeSelected(long timestamp, Long reminderTimestamp, RecurrenceRule repeatRule);&#10;    }&#10;&#10;    private OnDateTimeSelectedListener listener;&#10;&#10;    private CalendarView calendarView;&#10;    private TextView valueTime, valueReminder, valueRepeat;&#10;    private ImageButton btnClose, btnOk;&#10;    private long selectedDateMillis = -1;&#10;    private Long selectedTimeMillis = null;&#10;    private Long selectedReminderMillis = null;&#10;    private RecurrenceRule selectedRecurrenceRule;&#10;&#10;    private final DateFormat timeFormat = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault());&#10;    private final DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault());&#10;&#10;    public DateTimePickerBottomSheet() {&#10;        // Required empty public constructor&#10;    }&#10;&#10;    public static DateTimePickerBottomSheet newInstance(Long initialDueDate, Long initialReminderDate, RecurrenceRule recurrenceRule) {&#10;        DateTimePickerBottomSheet fragment = new DateTimePickerBottomSheet();&#10;        Bundle args = new Bundle();&#10;        if (initialDueDate != null) {&#10;            args.putLong(&quot;dueDate&quot;, initialDueDate);&#10;        }&#10;        if (initialReminderDate != null) {&#10;            args.putLong(&quot;reminderDate&quot;, initialReminderDate);&#10;        }&#10;        if (recurrenceRule != null) {&#10;            args.putSerializable(&quot;recurrenceRule&quot;, recurrenceRule);&#10;        }&#10;        fragment.setArguments(args);&#10;        return fragment;&#10;    }&#10;&#10;    public void setOnDateTimeSelectedListener(OnDateTimeSelectedListener l) {&#10;        this.listener = l;&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,&#10;                             @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.bottom_sheet_date_time_picker, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        calendarView = view.findViewById(R.id.calendarView);&#10;        valueTime = view.findViewById(R.id.value_time);&#10;        valueReminder = view.findViewById(R.id.value_reminder);&#10;        valueRepeat = view.findViewById(R.id.value_repeat);&#10;        btnClose = view.findViewById(R.id.btnClose);&#10;        btnOk = view.findViewById(R.id.btnOk);&#10;//        btnIdea = view.findViewById(R.id.findViewById);&#10;&#10;        // Initialize from arguments if provided&#10;        if (getArguments() != null) {&#10;            if (getArguments().containsKey(&quot;dueDate&quot;)) {&#10;                selectedDateMillis = getArguments().getLong(&quot;dueDate&quot;);&#10;                Calendar dueCal = Calendar.getInstance();&#10;                dueCal.setTimeInMillis(selectedDateMillis);&#10;                selectedTimeMillis = selectedDateMillis;&#10;                calendarView.setDate(selectedDateMillis, false, false);&#10;            } else {&#10;                selectedDateMillis = calendarView.getDate();&#10;            }&#10;&#10;            if (getArguments().containsKey(&quot;reminderDate&quot;)) {&#10;                selectedReminderMillis = getArguments().getLong(&quot;reminderDate&quot;);&#10;            }&#10;&#10;            if (getArguments().containsKey(&quot;recurrenceRule&quot;)) {&#10;                selectedRecurrenceRule = (RecurrenceRule) getArguments().getSerializable(&quot;recurrenceRule&quot;);&#10;            }&#10;        } else {&#10;            // init selectedDate = today&#10;            selectedDateMillis = calendarView.getDate();&#10;        }&#10;&#10;        calendarView.setOnDateChangeListener((view1, year, month, dayOfMonth) -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.set(year, month, dayOfMonth, 0, 0, 0);&#10;            c.set(Calendar.MILLISECOND, 0);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            &#10;            // Check if selected date matches any quick select chip and highlight it&#10;            checkAndHighlightMatchingChip(view);&#10;        });&#10;&#10;        // chips quick actions (today, tomorrow, 3 days...) - using IDs from layout&#10;        View chipToday = view.findViewById(R.id.chip_today);&#10;        View chipTomorrow = view.findViewById(R.id.chip_tomorrow);&#10;        View chip3Days = view.findViewById(R.id.chip_3days);&#10;        View chipNone = view.findViewById(R.id.chip_none);&#10;        View chipSunday = view.findViewById(R.id.chip_sunday);&#10;&#10;        chipToday.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipToday, chipTomorrow, chip3Days, chipNone, chipSunday);&#10;        });&#10;&#10;        chipTomorrow.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.add(Calendar.DAY_OF_YEAR, 1);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipTomorrow, chipToday, chip3Days, chipNone, chipSunday);&#10;        });&#10;&#10;        chip3Days.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.add(Calendar.DAY_OF_YEAR, 3);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chip3Days, chipToday, chipTomorrow, chipNone, chipSunday);&#10;        });&#10;&#10;        chipNone.setOnClickListener(v -&gt; {&#10;            selectedDateMillis = -1;&#10;            // you may visually clear selection; CalendarView default cannot clear selection easily&#10;            Toast.makeText(requireContext(), &quot;Bỏ chọn ngày&quot;, Toast.LENGTH_SHORT).show();&#10;            updateChipSelection(chipNone, chipToday, chipTomorrow, chip3Days, chipSunday);&#10;        });&#10;&#10;        chipSunday.setOnClickListener(v -&gt; {&#10;            // set to next Sunday&#10;            Calendar c = Calendar.getInstance();&#10;            while (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {&#10;                c.add(Calendar.DAY_OF_YEAR, 1);&#10;            }&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipSunday, chipToday, chipTomorrow, chip3Days, chipNone);&#10;        });&#10;&#10;        // time row click -&gt; time picker&#10;        View rowTime = view.findViewById(R.id.row_time);&#10;        rowTime.setOnClickListener(v -&gt; showTimePicker(true));&#10;&#10;        View rowReminder = view.findViewById(R.id.row_reminder);&#10;        rowReminder.setOnClickListener(v -&gt; showTimePicker(false));&#10;&#10;        View rowRepeat = view.findViewById(R.id.row_repeat);&#10;        rowRepeat.setOnClickListener(v -&gt; showRepeatDialog());&#10;&#10;        // close / ok&#10;        btnClose.setOnClickListener(v -&gt; dismiss());&#10;        btnOk.setOnClickListener(v -&gt; {&#10;            long resultTimestamp = -1;&#10;            Long resultReminderTimestamp = null;&#10;&#10;            if (selectedDateMillis != -1) {&#10;                if (selectedTimeMillis != null) {&#10;                    // merge date + time&#10;                    Calendar dateCal = Calendar.getInstance();&#10;                    dateCal.setTimeInMillis(selectedDateMillis);&#10;&#10;                    Calendar timeCal = Calendar.getInstance();&#10;                    timeCal.setTimeInMillis(selectedTimeMillis);&#10;&#10;                    dateCal.set(Calendar.HOUR_OF_DAY, timeCal.get(Calendar.HOUR_OF_DAY));&#10;                    dateCal.set(Calendar.MINUTE, timeCal.get(Calendar.MINUTE));&#10;                    dateCal.set(Calendar.SECOND, 0);&#10;                    resultTimestamp = dateCal.getTimeInMillis();&#10;                } else {&#10;                    // date only -&gt; default time to end of day (23:59:59)&#10;                    Calendar dateCal = Calendar.getInstance();&#10;                    dateCal.setTimeInMillis(selectedDateMillis);&#10;                    dateCal.set(Calendar.HOUR_OF_DAY, 23);&#10;                    dateCal.set(Calendar.MINUTE, 59);&#10;                    dateCal.set(Calendar.SECOND, 59);&#10;                    dateCal.set(Calendar.MILLISECOND, 999);&#10;                    resultTimestamp = dateCal.getTimeInMillis();&#10;                }&#10;            }&#10;&#10;            if (selectedReminderMillis != null &amp;&amp; selectedDateMillis != -1) {&#10;                Calendar reminderCal = Calendar.getInstance();&#10;                reminderCal.setTimeInMillis(selectedDateMillis);&#10;&#10;                Calendar reminderTimeCal = Calendar.getInstance();&#10;                reminderTimeCal.setTimeInMillis(selectedReminderMillis);&#10;&#10;                reminderCal.set(Calendar.HOUR_OF_DAY, reminderTimeCal.get(Calendar.HOUR_OF_DAY));&#10;                reminderCal.set(Calendar.MINUTE, reminderTimeCal.get(Calendar.MINUTE));&#10;                reminderCal.set(Calendar.SECOND, 0);&#10;                resultReminderTimestamp = reminderCal.getTimeInMillis();&#10;&#10;                // Validate: Reminder time must be before due time (if same day)&#10;                if (resultTimestamp != -1 &amp;&amp; resultReminderTimestamp &gt;= resultTimestamp) {&#10;                    Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải trước giờ deadline!&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                    return; // Don't close dialog&#10;                }&#10;&#10;                // Validate: Reminder time must be in future&#10;                if (resultReminderTimestamp &lt;= System.currentTimeMillis()) {&#10;                    Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải ở tương lai!&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                    return; // Don't close dialog&#10;                }&#10;            }&#10;&#10;            if (listener != null) {&#10;                listener.onDateTimeSelected(resultTimestamp, resultReminderTimestamp, selectedRecurrenceRule);&#10;            }&#10;            dismiss();&#10;        });&#10;&#10;        // initial UI values&#10;        updateUI();&#10;    }&#10;&#10;    private void updateUI() {&#10;        if (selectedTimeMillis != null) {&#10;            valueTime.setText(timeFormat.format(selectedTimeMillis));&#10;        } else {&#10;            valueTime.setText(&quot;Không&quot;);&#10;        }&#10;&#10;        if (selectedReminderMillis != null) {&#10;            valueReminder.setText(timeFormat.format(selectedReminderMillis));&#10;        } else {&#10;            valueReminder.setText(&quot;Không&quot;);&#10;        }&#10;&#10;        valueRepeat.setText(selectedRecurrenceRule != null ? selectedRecurrenceRule.getPattern() : &quot;Không&quot;);&#10;    }&#10;&#10;    private void showTimePicker(boolean isDueTime) {&#10;        // Get current time or existing selected time&#10;        Calendar currentCal = Calendar.getInstance();&#10;        int hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;        int minute = currentCal.get(Calendar.MINUTE);&#10;&#10;        // If editing existing time, use that value&#10;        if (isDueTime &amp;&amp; selectedTimeMillis != null) {&#10;            currentCal.setTimeInMillis(selectedTimeMillis);&#10;            hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = currentCal.get(Calendar.MINUTE);&#10;        } else if (!isDueTime &amp;&amp; selectedReminderMillis != null) {&#10;            currentCal.setTimeInMillis(selectedReminderMillis);&#10;            hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = currentCal.get(Calendar.MINUTE);&#10;        }&#10;&#10;        // Use MaterialTimePicker (like in Lich package)&#10;        String title = isDueTime ? &quot;Đặt giờ deadline&quot; : &quot;Đặt giờ nhắc nhở&quot;;&#10;&#10;        com.google.android.material.timepicker.MaterialTimePicker picker =&#10;                new com.google.android.material.timepicker.MaterialTimePicker.Builder()&#10;                .setTimeFormat(com.google.android.material.timepicker.TimeFormat.CLOCK_24H)&#10;                .setHour(hour)&#10;                .setMinute(minute)&#10;                .setTitleText(title)&#10;                .setInputMode(com.google.android.material.timepicker.MaterialTimePicker.INPUT_MODE_CLOCK)&#10;                .build();&#10;&#10;        picker.addOnPositiveButtonClickListener(v -&gt; {&#10;            int h = picker.getHour();&#10;            int m = picker.getMinute();&#10;&#10;            // Create time calendar&#10;            Calendar sel = Calendar.getInstance();&#10;            sel.set(Calendar.HOUR_OF_DAY, h);&#10;            sel.set(Calendar.MINUTE, m);&#10;            sel.set(Calendar.SECOND, 0);&#10;            sel.set(Calendar.MILLISECOND, 0);&#10;&#10;            if (isDueTime) {&#10;                selectedTimeMillis = sel.getTimeInMillis();&#10;                valueTime.setText(timeFormat.format(selectedTimeMillis));&#10;            } else {&#10;                selectedReminderMillis = sel.getTimeInMillis();&#10;                valueReminder.setText(timeFormat.format(selectedReminderMillis));&#10;            }&#10;        });&#10;&#10;        picker.show(getParentFragmentManager(), isDueTime ? &quot;TimePickerDue&quot; : &quot;TimePickerReminder&quot;);&#10;    }&#10;&#10;    private void showRepeatDialog() {&#10;        RecurrenceBottomSheet bottomSheet = RecurrenceBottomSheet.newInstance(selectedRecurrenceRule);&#10;        bottomSheet.setOnRecurrenceSelectedListener(rule -&gt; {&#10;            selectedRecurrenceRule = rule;&#10;            updateUI();&#10;        });&#10;        bottomSheet.show(getParentFragmentManager(), &quot;RecurrenceBottomSheet&quot;);&#10;    }&#10;&#10;    private void updateChipSelection(View selectedChip, View... otherChips) {&#10;        // Set selected chip to blue background and white text&#10;        selectedChip.setBackgroundResource(R.drawable.bg_chip_selected);&#10;        if (selectedChip instanceof TextView) {&#10;            ((TextView) selectedChip).setTextColor(getResources().getColor(R.color.white, null));&#10;        }&#10;&#10;        // Set other chips to gray background and primary text color&#10;        for (View chip : otherChips) {&#10;            chip.setBackgroundResource(R.drawable.bg_chip_gray);&#10;            if (chip instanceof TextView) {&#10;                ((TextView) chip).setTextColor(getResources().getColor(R.color.text_primary, null));&#10;            }&#10;        }&#10;    }&#10;&#10;    private void checkAndHighlightMatchingChip(View parentView) {&#10;        if (selectedDateMillis == -1) {&#10;            return;&#10;        }&#10;&#10;        View chipToday = parentView.findViewById(R.id.chip_today);&#10;        View chipTomorrow = parentView.findViewById(R.id.chip_tomorrow);&#10;        View chip3Days = parentView.findViewById(R.id.chip_3days);&#10;        View chipSunday = parentView.findViewById(R.id.chip_sunday);&#10;        View chipNone = parentView.findViewById(R.id.chip_none);&#10;&#10;        // Get selected date (reset time to compare only dates)&#10;        Calendar selectedCal = Calendar.getInstance();&#10;        selectedCal.setTimeInMillis(selectedDateMillis);&#10;        selectedCal.set(Calendar.HOUR_OF_DAY, 0);&#10;        selectedCal.set(Calendar.MINUTE, 0);&#10;        selectedCal.set(Calendar.SECOND, 0);&#10;        selectedCal.set(Calendar.MILLISECOND, 0);&#10;&#10;        // Check today&#10;        Calendar today = Calendar.getInstance();&#10;        today.set(Calendar.HOUR_OF_DAY, 0);&#10;        today.set(Calendar.MINUTE, 0);&#10;        today.set(Calendar.SECOND, 0);&#10;        today.set(Calendar.MILLISECOND, 0);&#10;&#10;        if (isSameDay(selectedCal, today)) {&#10;            updateChipSelection(chipToday, chipNone, chipTomorrow, chip3Days, chipSunday);&#10;            return;&#10;        }&#10;&#10;        // Check tomorrow&#10;        Calendar tomorrow = (Calendar) today.clone();&#10;        tomorrow.add(Calendar.DAY_OF_YEAR, 1);&#10;&#10;        if (isSameDay(selectedCal, tomorrow)) {&#10;            updateChipSelection(chipTomorrow, chipNone, chipToday, chip3Days, chipSunday);&#10;            return;&#10;        }&#10;&#10;        // Check 3 days later&#10;        Calendar threeDays = (Calendar) today.clone();&#10;        threeDays.add(Calendar.DAY_OF_YEAR, 3);&#10;&#10;        if (isSameDay(selectedCal, threeDays)) {&#10;            updateChipSelection(chip3Days, chipNone, chipToday, chipTomorrow, chipSunday);&#10;            return;&#10;        }&#10;&#10;        // Check next Sunday&#10;        Calendar nextSunday = (Calendar) today.clone();&#10;        while (nextSunday.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {&#10;            nextSunday.add(Calendar.DAY_OF_YEAR, 1);&#10;        }&#10;&#10;        if (isSameDay(selectedCal, nextSunday)) {&#10;            updateChipSelection(chipSunday, chipNone, chipToday, chipTomorrow, chip3Days);&#10;            return;&#10;        }&#10;&#10;        // If no match, don't highlight any chip (keep current state or highlight none)&#10;        // Reset all chips to gray&#10;        updateChipSelection(chipNone, chipToday, chipTomorrow, chip3Days, chipSunday);&#10;    }&#10;&#10;    private boolean isSameDay(Calendar cal1, Calendar cal2) {&#10;        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &amp;&amp;&#10;               cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/todolist/utils/NotificationHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/todolist/utils/NotificationHelper.java" />
              <option name="originalContent" value="package com.example.todolist.utils;&#10;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.PendingIntent;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;&#10;import androidx.core.app.NotificationCompat;&#10;&#10;import com.example.todolist.R;&#10;import com.example.todolist.Ui.activity.MainActivity;&#10;&#10;public class NotificationHelper {&#10;&#10;    private static final String CHANNEL_ID = &quot;task_reminder_channel&quot;;&#10;    private static final String CHANNEL_NAME = &quot;Task Reminders&quot;;&#10;    private static final String CHANNEL_DESC = &quot;Notifications for task reminders&quot;;&#10;&#10;    /**&#10;     * Create notification channel (required for Android O and above)&#10;     */&#10;    public static void createNotificationChannel(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationChannel channel = new NotificationChannel(&#10;                    CHANNEL_ID,&#10;                    CHANNEL_NAME,&#10;                    NotificationManager.IMPORTANCE_HIGH&#10;            );&#10;            channel.setDescription(CHANNEL_DESC);&#10;            channel.enableVibration(true);&#10;            channel.enableLights(true);&#10;&#10;            NotificationManager manager = context.getSystemService(NotificationManager.class);&#10;            if (manager != null) {&#10;                manager.createNotificationChannel(channel);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Show notification for task reminder&#10;     */&#10;    public static void showTaskReminder(Context context, long taskId, String taskTitle, String taskDescription) {&#10;        // Check if we have permission to post notifications (Android 13+)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (context.checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS)&#10;                    != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                android.util.Log.w(&quot;NotificationHelper&quot;, &quot;POST_NOTIFICATIONS permission not granted&quot;);&#10;                return;&#10;            }&#10;        }&#10;&#10;        NotificationManager notificationManager =&#10;                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#10;&#10;        if (notificationManager == null) {&#10;            return;&#10;        }&#10;&#10;        // Create intent to open app when notification is clicked&#10;        Intent intent = new Intent(context, MainActivity.class);&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;        intent.putExtra(&quot;task_id&quot;, taskId);&#10;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#10;                context,&#10;                (int) taskId,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;&#10;        // Build notification&#10;        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)&#10;                .setSmallIcon(R.drawable.ic_bell)&#10;                .setContentTitle(taskTitle)&#10;                .setContentText(taskDescription.isEmpty() ? &quot;Đã đến giờ làm việc!&quot; : taskDescription)&#10;                .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;                .setCategory(NotificationCompat.CATEGORY_REMINDER)&#10;                .setAutoCancel(true)&#10;                .setContentIntent(pendingIntent)&#10;                .setVibrate(new long[]{0, 500, 250, 500});&#10;&#10;        // Show notification&#10;        notificationManager.notify((int) taskId, builder.build());&#10;    }&#10;&#10;    /**&#10;     * Cancel a scheduled notification&#10;     */&#10;    public static void cancelNotification(Context context, int notificationId) {&#10;        NotificationManager notificationManager =&#10;                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#10;&#10;        if (notificationManager != null) {&#10;            notificationManager.cancel(notificationId);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.todolist.utils;&#13;&#10;&#13;&#10;import android.app.NotificationChannel;&#13;&#10;import android.app.NotificationManager;&#13;&#10;import android.app.PendingIntent;&#13;&#10;import android.content.Context;&#13;&#10;import android.content.Intent;&#13;&#10;import android.os.Build;&#13;&#10;&#13;&#10;import androidx.core.app.NotificationCompat;&#13;&#10;&#13;&#10;import com.example.todolist.R;&#13;&#10;import com.example.todolist.Ui.activity.MainActivity;&#13;&#10;&#13;&#10;public class NotificationHelper {&#13;&#10;&#13;&#10;    private static final String CHANNEL_ID = &quot;task_reminder_channel&quot;;&#13;&#10;    private static final String CHANNEL_NAME = &quot;Task Reminders&quot;;&#13;&#10;    private static final String CHANNEL_DESC = &quot;Notifications for task reminders&quot;;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create notification channel (required for Android O and above)&#13;&#10;     */&#13;&#10;    public static void createNotificationChannel(Context context) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#13;&#10;            NotificationChannel channel = new NotificationChannel(&#13;&#10;                    CHANNEL_ID,&#13;&#10;                    CHANNEL_NAME,&#13;&#10;                    NotificationManager.IMPORTANCE_HIGH&#13;&#10;            );&#13;&#10;            channel.setDescription(CHANNEL_DESC);&#13;&#10;            channel.enableVibration(true);&#13;&#10;            channel.enableLights(true);&#13;&#10;&#13;&#10;            NotificationManager manager = context.getSystemService(NotificationManager.class);&#13;&#10;            if (manager != null) {&#13;&#10;                manager.createNotificationChannel(channel);&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Show notification for task reminder&#13;&#10;     */&#13;&#10;    public static void showTaskReminder(Context context, long taskId, String taskTitle, String taskDescription) {&#13;&#10;        // Check if we have permission to post notifications (Android 13+)&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#13;&#10;            if (context.checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS)&#13;&#10;                    != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#13;&#10;                android.util.Log.w(&quot;NotificationHelper&quot;, &quot;POST_NOTIFICATIONS permission not granted&quot;);&#13;&#10;                return;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        NotificationManager notificationManager =&#13;&#10;                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#13;&#10;&#13;&#10;        if (notificationManager == null) {&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Create intent to open app when notification is clicked&#13;&#10;        Intent intent = new Intent(context, MainActivity.class);&#13;&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#13;&#10;        intent.putExtra(&quot;task_id&quot;, taskId);&#13;&#10;&#13;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#13;&#10;                context,&#13;&#10;                (int) taskId,&#13;&#10;                intent,&#13;&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#13;&#10;        );&#13;&#10;&#13;&#10;        // Build notification&#10;        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)&#10;                .setSmallIcon(R.drawable.ic_bell)&#10;                .setContentTitle(taskTitle)&#10;                .setContentText(taskDescription.isEmpty() ? &quot;Đã đến giờ làm việc!&quot; : taskDescription)&#13;&#10;                .setPriority(NotificationCompat.PRIORITY_HIGH)&#13;&#10;                .setCategory(NotificationCompat.CATEGORY_REMINDER)&#13;&#10;                .setAutoCancel(true)&#13;&#10;                .setContentIntent(pendingIntent)&#13;&#10;                .setVibrate(new long[]{0, 500, 250, 500});&#13;&#10;&#13;&#10;        // Show notification&#13;&#10;        notificationManager.notify((int) taskId, builder.build());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Cancel a scheduled notification&#13;&#10;     */&#13;&#10;    public static void cancelNotification(Context context, int notificationId) {&#13;&#10;        NotificationManager notificationManager =&#13;&#10;                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#13;&#10;&#13;&#10;        if (notificationManager != null) {&#13;&#10;            notificationManager.cancel(notificationId);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>