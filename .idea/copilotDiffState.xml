<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/activity/Lich/App.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/activity/Lich/App.java" />
              <option name="originalContent" value="package com.example.todolist.Ui.activity.Lich;&#10;&#10;import android.app.Application;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.os.Build;&#10;&#10;// Lớp này chạy một lần duy nhất khi ứng dụng khởi động&#10;public class App extends Application {&#10;&#10;    public static final String CHANNEL_ID = &quot;REMINDER_CHANNEL_1&quot;;&#10;&#10;    @Override&#10;    public void onCreate() {&#10;        super.onCreate();&#10;        createNotificationChannel();&#10;    }&#10;&#10;    private void createNotificationChannel() {&#10;        // Chỉ tạo kênh trên API 26 (Android 8.0) trở lên&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationManager notificationManager = getSystemService(NotificationManager.class);&#10;            &#10;            // Channel 1: For Lich/AlarmReceiver&#10;            CharSequence name = &quot;Kênh Nhắc nhở Nhiệm vụ&quot;;&#10;            String description = &quot;Kênh để hiển thị thông báo nhắc nhở nhiệm vụ&quot;;&#10;            int importance = NotificationManager.IMPORTANCE_HIGH; // Ưu tiên cao&#10;&#10;            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);&#10;            channel.setDescription(description);&#10;            channel.enableVibration(true);&#10;            channel.enableLights(true);&#10;            notificationManager.createNotificationChannel(channel);&#10;            &#10;            // Channel 2: For task reminders (NotificationHelper)&#10;            NotificationChannel taskReminderChannel = new NotificationChannel(&#10;                    &quot;task_reminder_channel&quot;,&#10;                    &quot;Task Reminders&quot;,&#10;                    NotificationManager.IMPORTANCE_HIGH&#10;            );&#10;            taskReminderChannel.setDescription(&quot;Notifications for task reminders&quot;);&#10;            taskReminderChannel.enableVibration(true);&#10;            taskReminderChannel.enableLights(true);&#10;            notificationManager.createNotificationChannel(taskReminderChannel);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.todolist.Ui.activity.Lich;&#13;&#10;&#13;&#10;import android.app.Application;&#13;&#10;import android.app.NotificationChannel;&#13;&#10;import android.app.NotificationManager;&#13;&#10;import android.os.Build;&#13;&#10;&#13;&#10;// Lớp này chạy một lần duy nhất khi ứng dụng khởi động&#13;&#10;public class App extends Application {&#13;&#10;&#13;&#10;    public static final String CHANNEL_ID = &quot;REMINDER_CHANNEL_1&quot;;&#13;&#10;&#13;&#10;    @Override&#13;&#10;    public void onCreate() {&#13;&#10;        super.onCreate();&#13;&#10;        createNotificationChannel();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void createNotificationChannel() {&#10;        // Chỉ tạo kênh trên API 26 (Android 8.0) trở lên&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationManager notificationManager = getSystemService(NotificationManager.class);&#10;            &#10;            // Channel 1: For Lich/AlarmReceiver&#10;            CharSequence name = &quot;Kênh Nhắc nhở Nhiệm vụ&quot;;&#10;            String description = &quot;Kênh để hiển thị thông báo nhắc nhở nhiệm vụ&quot;;&#10;            int importance = NotificationManager.IMPORTANCE_HIGH; // Ưu tiên cao&#10;&#10;            NotificationChannel channel = new NotificationChannel(CHANNEL_ID, name, importance);&#10;            channel.setDescription(description);&#10;            channel.enableVibration(true);&#10;            channel.enableLights(true);&#10;            notificationManager.createNotificationChannel(channel);&#10;            &#10;            // Channel 2: For task reminders (NotificationHelper)&#10;            NotificationChannel taskReminderChannel = new NotificationChannel(&#10;                    &quot;task_reminder_channel&quot;,&#10;                    &quot;Task Reminders&quot;,&#10;                    NotificationManager.IMPORTANCE_HIGH&#10;            );&#10;            taskReminderChannel.setDescription(&quot;Notifications for task reminders&quot;);&#10;            taskReminderChannel.enableVibration(true);&#10;            taskReminderChannel.enableLights(true);&#10;            notificationManager.createNotificationChannel(taskReminderChannel);&#10;        }&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/maintaskfragement/DateTimePickerBottomSheet.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/todolist/Ui/maintaskfragement/DateTimePickerBottomSheet.java" />
              <option name="originalContent" value="package com.example.todolist.Ui.maintaskfragement;&#10;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.CalendarView;&#10;import android.widget.ImageButton;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;&#10;import com.example.todolist.Data.entity.RecurrenceRule;&#10;import com.example.todolist.R;&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment;&#10;&#10;import java.text.DateFormat;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Locale;&#10;&#10;public class DateTimePickerBottomSheet extends BottomSheetDialogFragment {&#10;&#10;    public interface OnDateTimeSelectedListener {&#10;        void onDateTimeSelected(long timestamp, Long reminderTimestamp, RecurrenceRule repeatRule);&#10;    }&#10;&#10;    private OnDateTimeSelectedListener listener;&#10;&#10;    private CalendarView calendarView;&#10;    private TextView valueTime, valueReminder, valueRepeat;&#10;    private ImageButton btnClose, btnOk;&#10;    private long selectedDateMillis = -1;&#10;    private Long selectedTimeMillis = null;&#10;    private Long selectedReminderMillis = null;&#10;    private RecurrenceRule selectedRecurrenceRule;&#10;&#10;    private final DateFormat timeFormat = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault());&#10;    private final DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault());&#10;&#10;    public DateTimePickerBottomSheet() {&#10;        // Required empty public constructor&#10;    }&#10;&#10;    public static DateTimePickerBottomSheet newInstance(Long initialDueDate, Long initialReminderDate, RecurrenceRule recurrenceRule) {&#10;        DateTimePickerBottomSheet fragment = new DateTimePickerBottomSheet();&#10;        Bundle args = new Bundle();&#10;        if (initialDueDate != null) {&#10;            args.putLong(&quot;dueDate&quot;, initialDueDate);&#10;        }&#10;        if (initialReminderDate != null) {&#10;            args.putLong(&quot;reminderDate&quot;, initialReminderDate);&#10;        }&#10;        if (recurrenceRule != null) {&#10;            args.putSerializable(&quot;recurrenceRule&quot;, recurrenceRule);&#10;        }&#10;        fragment.setArguments(args);&#10;        return fragment;&#10;    }&#10;&#10;    public void setOnDateTimeSelectedListener(OnDateTimeSelectedListener l) {&#10;        this.listener = l;&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,&#10;                             @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.bottom_sheet_date_time_picker, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        calendarView = view.findViewById(R.id.calendarView);&#10;        valueTime = view.findViewById(R.id.value_time);&#10;        valueReminder = view.findViewById(R.id.value_reminder);&#10;        valueRepeat = view.findViewById(R.id.value_repeat);&#10;        btnClose = view.findViewById(R.id.btnClose);&#10;        btnOk = view.findViewById(R.id.btnOk);&#10;//        btnIdea = view.findViewById(R.id.findViewById);&#10;&#10;        // Initialize from arguments if provided&#10;        if (getArguments() != null) {&#10;            if (getArguments().containsKey(&quot;dueDate&quot;)) {&#10;                selectedDateMillis = getArguments().getLong(&quot;dueDate&quot;);&#10;                Calendar dueCal = Calendar.getInstance();&#10;                dueCal.setTimeInMillis(selectedDateMillis);&#10;                selectedTimeMillis = selectedDateMillis;&#10;                calendarView.setDate(selectedDateMillis, false, false);&#10;            } else {&#10;                selectedDateMillis = calendarView.getDate();&#10;            }&#10;&#10;            if (getArguments().containsKey(&quot;reminderDate&quot;)) {&#10;                selectedReminderMillis = getArguments().getLong(&quot;reminderDate&quot;);&#10;            }&#10;&#10;            if (getArguments().containsKey(&quot;recurrenceRule&quot;)) {&#10;                selectedRecurrenceRule = (RecurrenceRule) getArguments().getSerializable(&quot;recurrenceRule&quot;);&#10;            }&#10;        } else {&#10;            // init selectedDate = today&#10;            selectedDateMillis = calendarView.getDate();&#10;        }&#10;&#10;        calendarView.setOnDateChangeListener((view1, year, month, dayOfMonth) -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.set(year, month, dayOfMonth, 0, 0, 0);&#10;            c.set(Calendar.MILLISECOND, 0);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;        });&#10;&#10;        // chips quick actions (today, tomorrow, 3 days...) - using IDs from layout&#10;        View chipToday = view.findViewById(R.id.chip_today);&#10;        View chipTomorrow = view.findViewById(R.id.chip_tomorrow);&#10;        View chip3Days = view.findViewById(R.id.chip_3days);&#10;        View chipNone = view.findViewById(R.id.chip_none);&#10;        View chipSunday = view.findViewById(R.id.chip_sunday);&#10;&#10;        chipToday.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipToday, chipTomorrow, chip3Days, chipNone, chipSunday);&#10;        });&#10;&#10;        chipTomorrow.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.add(Calendar.DAY_OF_YEAR, 1);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipTomorrow, chipToday, chip3Days, chipNone, chipSunday);&#10;        });&#10;&#10;        chip3Days.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.add(Calendar.DAY_OF_YEAR, 3);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chip3Days, chipToday, chipTomorrow, chipNone, chipSunday);&#10;        });&#10;&#10;        chipNone.setOnClickListener(v -&gt; {&#10;            selectedDateMillis = -1;&#10;            // you may visually clear selection; CalendarView default cannot clear selection easily&#10;            Toast.makeText(requireContext(), &quot;Bỏ chọn ngày&quot;, Toast.LENGTH_SHORT).show();&#10;            updateChipSelection(chipNone, chipToday, chipTomorrow, chip3Days, chipSunday);&#10;        });&#10;&#10;        chipSunday.setOnClickListener(v -&gt; {&#10;            // set to next Sunday&#10;            Calendar c = Calendar.getInstance();&#10;            while (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {&#10;                c.add(Calendar.DAY_OF_YEAR, 1);&#10;            }&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipSunday, chipToday, chipTomorrow, chip3Days, chipNone);&#10;        });&#10;&#10;        // time row click -&gt; time picker&#10;        View rowTime = view.findViewById(R.id.row_time);&#10;        rowTime.setOnClickListener(v -&gt; showTimePicker(true));&#10;&#10;        View rowReminder = view.findViewById(R.id.row_reminder);&#10;        rowReminder.setOnClickListener(v -&gt; showTimePicker(false));&#10;&#10;        View rowRepeat = view.findViewById(R.id.row_repeat);&#10;        rowRepeat.setOnClickListener(v -&gt; showRepeatDialog());&#10;&#10;        // close / ok&#10;        btnClose.setOnClickListener(v -&gt; dismiss());&#10;        btnOk.setOnClickListener(v -&gt; {&#10;            long resultTimestamp = -1;&#10;            Long resultReminderTimestamp = null;&#10;&#10;            if (selectedDateMillis != -1) {&#10;                if (selectedTimeMillis != null) {&#10;                    // merge date + time&#10;                    Calendar dateCal = Calendar.getInstance();&#10;                    dateCal.setTimeInMillis(selectedDateMillis);&#10;&#10;                    Calendar timeCal = Calendar.getInstance();&#10;                    timeCal.setTimeInMillis(selectedTimeMillis);&#10;&#10;                    dateCal.set(Calendar.HOUR_OF_DAY, timeCal.get(Calendar.HOUR_OF_DAY));&#10;                    dateCal.set(Calendar.MINUTE, timeCal.get(Calendar.MINUTE));&#10;                    dateCal.set(Calendar.SECOND, 0);&#10;                    resultTimestamp = dateCal.getTimeInMillis();&#10;                } else {&#10;                    // date only -&gt; default time to end of day (23:59:59)&#10;                    Calendar dateCal = Calendar.getInstance();&#10;                    dateCal.setTimeInMillis(selectedDateMillis);&#10;                    dateCal.set(Calendar.HOUR_OF_DAY, 23);&#10;                    dateCal.set(Calendar.MINUTE, 59);&#10;                    dateCal.set(Calendar.SECOND, 59);&#10;                    dateCal.set(Calendar.MILLISECOND, 999);&#10;                    resultTimestamp = dateCal.getTimeInMillis();&#10;                }&#10;            }&#10;&#10;            if (selectedReminderMillis != null &amp;&amp; selectedDateMillis != -1) {&#10;                Calendar reminderCal = Calendar.getInstance();&#10;                reminderCal.setTimeInMillis(selectedDateMillis);&#10;&#10;                Calendar reminderTimeCal = Calendar.getInstance();&#10;                reminderTimeCal.setTimeInMillis(selectedReminderMillis);&#10;&#10;                reminderCal.set(Calendar.HOUR_OF_DAY, reminderTimeCal.get(Calendar.HOUR_OF_DAY));&#10;                reminderCal.set(Calendar.MINUTE, reminderTimeCal.get(Calendar.MINUTE));&#10;                reminderCal.set(Calendar.SECOND, 0);&#10;                resultReminderTimestamp = reminderCal.getTimeInMillis();&#10;&#10;                // Validate: Reminder time must be before due time (if same day)&#10;                if (resultTimestamp != -1 &amp;&amp; resultReminderTimestamp &gt;= resultTimestamp) {&#10;                    Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải trước giờ deadline!&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                    return; // Don't close dialog&#10;                }&#10;&#10;                // Validate: Reminder time must be in future&#10;                if (resultReminderTimestamp &lt;= System.currentTimeMillis()) {&#10;                    Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải ở tương lai!&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                    return; // Don't close dialog&#10;                }&#10;            }&#10;&#10;            if (listener != null) {&#10;                listener.onDateTimeSelected(resultTimestamp, resultReminderTimestamp, selectedRecurrenceRule);&#10;            }&#10;            dismiss();&#10;        });&#10;&#10;        // initial UI values&#10;        updateUI();&#10;    }&#10;&#10;    private void updateUI() {&#10;        if (selectedTimeMillis != null) {&#10;            valueTime.setText(timeFormat.format(selectedTimeMillis));&#10;        } else {&#10;            valueTime.setText(&quot;Không&quot;);&#10;        }&#10;&#10;        if (selectedReminderMillis != null) {&#10;            valueReminder.setText(timeFormat.format(selectedReminderMillis));&#10;        } else {&#10;            valueReminder.setText(&quot;Không&quot;);&#10;        }&#10;&#10;        valueRepeat.setText(selectedRecurrenceRule != null ? selectedRecurrenceRule.getPattern() : &quot;Không&quot;);&#10;    }&#10;&#10;    private void showTimePicker(boolean isDueTime) {&#10;        // Get current time or existing selected time&#10;        Calendar currentCal = Calendar.getInstance();&#10;        int hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;        int minute = currentCal.get(Calendar.MINUTE);&#10;&#10;        // If editing existing time, use that value&#10;        if (isDueTime &amp;&amp; selectedTimeMillis != null) {&#10;            currentCal.setTimeInMillis(selectedTimeMillis);&#10;            hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = currentCal.get(Calendar.MINUTE);&#10;        } else if (!isDueTime &amp;&amp; selectedReminderMillis != null) {&#10;            currentCal.setTimeInMillis(selectedReminderMillis);&#10;            hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = currentCal.get(Calendar.MINUTE);&#10;        }&#10;&#10;        // Use MaterialTimePicker (like in Lich package)&#10;        String title = isDueTime ? &quot;Đặt giờ deadline&quot; : &quot;Đặt giờ nhắc nhở&quot;;&#10;&#10;        com.google.android.material.timepicker.MaterialTimePicker picker =&#10;                new com.google.android.material.timepicker.MaterialTimePicker.Builder()&#10;                .setTimeFormat(com.google.android.material.timepicker.TimeFormat.CLOCK_24H)&#10;                .setHour(hour)&#10;                .setMinute(minute)&#10;                .setTitleText(title)&#10;                .setInputMode(com.google.android.material.timepicker.MaterialTimePicker.INPUT_MODE_CLOCK)&#10;                .build();&#10;&#10;        picker.addOnPositiveButtonClickListener(v -&gt; {&#10;            int h = picker.getHour();&#10;            int m = picker.getMinute();&#10;&#10;            // Create time calendar&#10;            Calendar sel = Calendar.getInstance();&#10;            sel.set(Calendar.HOUR_OF_DAY, h);&#10;            sel.set(Calendar.MINUTE, m);&#10;            sel.set(Calendar.SECOND, 0);&#10;            sel.set(Calendar.MILLISECOND, 0);&#10;&#10;            if (isDueTime) {&#10;                selectedTimeMillis = sel.getTimeInMillis();&#10;                valueTime.setText(timeFormat.format(selectedTimeMillis));&#10;            } else {&#10;                selectedReminderMillis = sel.getTimeInMillis();&#10;                valueReminder.setText(timeFormat.format(selectedReminderMillis));&#10;            }&#10;        });&#10;&#10;        picker.show(getParentFragmentManager(), isDueTime ? &quot;TimePickerDue&quot; : &quot;TimePickerReminder&quot;);&#10;    }&#10;&#10;    private void showRepeatDialog() {&#10;        RecurrenceBottomSheet bottomSheet = RecurrenceBottomSheet.newInstance(selectedRecurrenceRule);&#10;        bottomSheet.setOnRecurrenceSelectedListener(rule -&gt; {&#10;            selectedRecurrenceRule = rule;&#10;            updateUI();&#10;        });&#10;        bottomSheet.show(getParentFragmentManager(), &quot;RecurrenceBottomSheet&quot;);&#10;    }&#10;&#10;    private void updateChipSelection(View selectedChip, View... otherChips) {&#10;        // Set selected chip to blue background and white text&#10;        selectedChip.setBackgroundResource(R.drawable.bg_chip_selected);&#10;        if (selectedChip instanceof TextView) {&#10;            ((TextView) selectedChip).setTextColor(getResources().getColor(R.color.white, null));&#10;        }&#10;&#10;        // Set other chips to gray background and primary text color&#10;        for (View chip : otherChips) {&#10;            chip.setBackgroundResource(R.drawable.bg_chip_gray);&#10;            if (chip instanceof TextView) {&#10;                ((TextView) chip).setTextColor(getResources().getColor(R.color.text_primary, null));&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.todolist.Ui.maintaskfragement;&#10;&#10;import android.os.Bundle;&#10;import android.view.LayoutInflater;&#10;import android.view.View;&#10;import android.view.ViewGroup;&#10;import android.widget.CalendarView;&#10;import android.widget.ImageButton;&#10;import android.widget.TextView;&#10;import android.widget.Toast;&#10;&#10;import androidx.annotation.NonNull;&#10;import androidx.annotation.Nullable;&#10;&#10;import com.example.todolist.Data.entity.RecurrenceRule;&#10;import com.example.todolist.R;&#10;import com.google.android.material.bottomsheet.BottomSheetDialogFragment;&#10;&#10;import java.text.DateFormat;&#10;import java.text.SimpleDateFormat;&#10;import java.util.Calendar;&#10;import java.util.Locale;&#10;&#10;public class DateTimePickerBottomSheet extends BottomSheetDialogFragment {&#10;&#10;    public interface OnDateTimeSelectedListener {&#10;        void onDateTimeSelected(long timestamp, Long reminderTimestamp, RecurrenceRule repeatRule);&#10;    }&#10;&#10;    private OnDateTimeSelectedListener listener;&#10;&#10;    private CalendarView calendarView;&#10;    private TextView valueTime, valueReminder, valueRepeat;&#10;    private ImageButton btnClose, btnOk;&#10;    private long selectedDateMillis = -1;&#10;    private Long selectedTimeMillis = null;&#10;    private Long selectedReminderMillis = null;&#10;    private RecurrenceRule selectedRecurrenceRule;&#10;&#10;    private final DateFormat timeFormat = new SimpleDateFormat(&quot;HH:mm&quot;, Locale.getDefault());&#10;    private final DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;, Locale.getDefault());&#10;&#10;    public DateTimePickerBottomSheet() {&#10;        // Required empty public constructor&#10;    }&#10;&#10;    public static DateTimePickerBottomSheet newInstance(Long initialDueDate, Long initialReminderDate, RecurrenceRule recurrenceRule) {&#10;        DateTimePickerBottomSheet fragment = new DateTimePickerBottomSheet();&#10;        Bundle args = new Bundle();&#10;        if (initialDueDate != null) {&#10;            args.putLong(&quot;dueDate&quot;, initialDueDate);&#10;        }&#10;        if (initialReminderDate != null) {&#10;            args.putLong(&quot;reminderDate&quot;, initialReminderDate);&#10;        }&#10;        if (recurrenceRule != null) {&#10;            args.putSerializable(&quot;recurrenceRule&quot;, recurrenceRule);&#10;        }&#10;        fragment.setArguments(args);&#10;        return fragment;&#10;    }&#10;&#10;    public void setOnDateTimeSelectedListener(OnDateTimeSelectedListener l) {&#10;        this.listener = l;&#10;    }&#10;&#10;    @Nullable&#10;    @Override&#10;    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container,&#10;                             @Nullable Bundle savedInstanceState) {&#10;        return inflater.inflate(R.layout.bottom_sheet_date_time_picker, container, false);&#10;    }&#10;&#10;    @Override&#10;    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {&#10;        calendarView = view.findViewById(R.id.calendarView);&#10;        valueTime = view.findViewById(R.id.value_time);&#10;        valueReminder = view.findViewById(R.id.value_reminder);&#10;        valueRepeat = view.findViewById(R.id.value_repeat);&#10;        btnClose = view.findViewById(R.id.btnClose);&#10;        btnOk = view.findViewById(R.id.btnOk);&#10;//        btnIdea = view.findViewById(R.id.findViewById);&#10;&#10;        // Initialize from arguments if provided&#10;        if (getArguments() != null) {&#10;            if (getArguments().containsKey(&quot;dueDate&quot;)) {&#10;                selectedDateMillis = getArguments().getLong(&quot;dueDate&quot;);&#10;                Calendar dueCal = Calendar.getInstance();&#10;                dueCal.setTimeInMillis(selectedDateMillis);&#10;                selectedTimeMillis = selectedDateMillis;&#10;                calendarView.setDate(selectedDateMillis, false, false);&#10;            } else {&#10;                selectedDateMillis = calendarView.getDate();&#10;            }&#10;&#10;            if (getArguments().containsKey(&quot;reminderDate&quot;)) {&#10;                selectedReminderMillis = getArguments().getLong(&quot;reminderDate&quot;);&#10;            }&#10;&#10;            if (getArguments().containsKey(&quot;recurrenceRule&quot;)) {&#10;                selectedRecurrenceRule = (RecurrenceRule) getArguments().getSerializable(&quot;recurrenceRule&quot;);&#10;            }&#10;        } else {&#10;            // init selectedDate = today&#10;            selectedDateMillis = calendarView.getDate();&#10;        }&#10;&#10;        calendarView.setOnDateChangeListener((view1, year, month, dayOfMonth) -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.set(year, month, dayOfMonth, 0, 0, 0);&#10;            c.set(Calendar.MILLISECOND, 0);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            &#10;            // Check if selected date matches any quick select chip and highlight it&#10;            checkAndHighlightMatchingChip(view);&#10;        });&#10;&#10;        // chips quick actions (today, tomorrow, 3 days...) - using IDs from layout&#10;        View chipToday = view.findViewById(R.id.chip_today);&#10;        View chipTomorrow = view.findViewById(R.id.chip_tomorrow);&#10;        View chip3Days = view.findViewById(R.id.chip_3days);&#10;        View chipNone = view.findViewById(R.id.chip_none);&#10;        View chipSunday = view.findViewById(R.id.chip_sunday);&#10;&#10;        chipToday.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipToday, chipTomorrow, chip3Days, chipNone, chipSunday);&#10;        });&#10;&#10;        chipTomorrow.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.add(Calendar.DAY_OF_YEAR, 1);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipTomorrow, chipToday, chip3Days, chipNone, chipSunday);&#10;        });&#10;&#10;        chip3Days.setOnClickListener(v -&gt; {&#10;            Calendar c = Calendar.getInstance();&#10;            c.add(Calendar.DAY_OF_YEAR, 3);&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chip3Days, chipToday, chipTomorrow, chipNone, chipSunday);&#10;        });&#10;&#10;        chipNone.setOnClickListener(v -&gt; {&#10;            selectedDateMillis = -1;&#10;            // you may visually clear selection; CalendarView default cannot clear selection easily&#10;            Toast.makeText(requireContext(), &quot;Bỏ chọn ngày&quot;, Toast.LENGTH_SHORT).show();&#10;            updateChipSelection(chipNone, chipToday, chipTomorrow, chip3Days, chipSunday);&#10;        });&#10;&#10;        chipSunday.setOnClickListener(v -&gt; {&#10;            // set to next Sunday&#10;            Calendar c = Calendar.getInstance();&#10;            while (c.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {&#10;                c.add(Calendar.DAY_OF_YEAR, 1);&#10;            }&#10;            selectedDateMillis = c.getTimeInMillis();&#10;            calendarView.setDate(selectedDateMillis, true, true);&#10;            updateChipSelection(chipSunday, chipToday, chipTomorrow, chip3Days, chipNone);&#10;        });&#10;&#10;        // time row click -&gt; time picker&#10;        View rowTime = view.findViewById(R.id.row_time);&#10;        rowTime.setOnClickListener(v -&gt; showTimePicker(true));&#10;&#10;        View rowReminder = view.findViewById(R.id.row_reminder);&#10;        rowReminder.setOnClickListener(v -&gt; showTimePicker(false));&#10;&#10;        View rowRepeat = view.findViewById(R.id.row_repeat);&#10;        rowRepeat.setOnClickListener(v -&gt; showRepeatDialog());&#10;&#10;        // close / ok&#10;        btnClose.setOnClickListener(v -&gt; dismiss());&#10;        btnOk.setOnClickListener(v -&gt; {&#10;            long resultTimestamp = -1;&#10;            Long resultReminderTimestamp = null;&#10;&#10;            if (selectedDateMillis != -1) {&#10;                if (selectedTimeMillis != null) {&#10;                    // merge date + time&#10;                    Calendar dateCal = Calendar.getInstance();&#10;                    dateCal.setTimeInMillis(selectedDateMillis);&#10;&#10;                    Calendar timeCal = Calendar.getInstance();&#10;                    timeCal.setTimeInMillis(selectedTimeMillis);&#10;&#10;                    dateCal.set(Calendar.HOUR_OF_DAY, timeCal.get(Calendar.HOUR_OF_DAY));&#10;                    dateCal.set(Calendar.MINUTE, timeCal.get(Calendar.MINUTE));&#10;                    dateCal.set(Calendar.SECOND, 0);&#10;                    resultTimestamp = dateCal.getTimeInMillis();&#10;                } else {&#10;                    // date only -&gt; default time to end of day (23:59:59)&#10;                    Calendar dateCal = Calendar.getInstance();&#10;                    dateCal.setTimeInMillis(selectedDateMillis);&#10;                    dateCal.set(Calendar.HOUR_OF_DAY, 23);&#10;                    dateCal.set(Calendar.MINUTE, 59);&#10;                    dateCal.set(Calendar.SECOND, 59);&#10;                    dateCal.set(Calendar.MILLISECOND, 999);&#10;                    resultTimestamp = dateCal.getTimeInMillis();&#10;                }&#10;            }&#10;&#10;            if (selectedReminderMillis != null &amp;&amp; selectedDateMillis != -1) {&#10;                Calendar reminderCal = Calendar.getInstance();&#10;                reminderCal.setTimeInMillis(selectedDateMillis);&#10;&#10;                Calendar reminderTimeCal = Calendar.getInstance();&#10;                reminderTimeCal.setTimeInMillis(selectedReminderMillis);&#10;&#10;                reminderCal.set(Calendar.HOUR_OF_DAY, reminderTimeCal.get(Calendar.HOUR_OF_DAY));&#10;                reminderCal.set(Calendar.MINUTE, reminderTimeCal.get(Calendar.MINUTE));&#10;                reminderCal.set(Calendar.SECOND, 0);&#10;                resultReminderTimestamp = reminderCal.getTimeInMillis();&#10;&#10;                // Validate: Reminder time must be before due time (if same day)&#10;                if (resultTimestamp != -1 &amp;&amp; resultReminderTimestamp &gt;= resultTimestamp) {&#10;                    Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải trước giờ deadline!&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                    return; // Don't close dialog&#10;                }&#10;&#10;                // Validate: Reminder time must be in future&#10;                if (resultReminderTimestamp &lt;= System.currentTimeMillis()) {&#10;                    Toast.makeText(requireContext(),&#10;                        &quot;Thời gian nhắc nhở phải ở tương lai!&quot;,&#10;                        Toast.LENGTH_SHORT).show();&#10;                    return; // Don't close dialog&#10;                }&#10;            }&#10;&#10;            if (listener != null) {&#10;                listener.onDateTimeSelected(resultTimestamp, resultReminderTimestamp, selectedRecurrenceRule);&#10;            }&#10;            dismiss();&#10;        });&#10;&#10;        // initial UI values&#10;        updateUI();&#10;    }&#10;&#10;    private void updateUI() {&#10;        if (selectedTimeMillis != null) {&#10;            valueTime.setText(timeFormat.format(selectedTimeMillis));&#10;        } else {&#10;            valueTime.setText(&quot;Không&quot;);&#10;        }&#10;&#10;        if (selectedReminderMillis != null) {&#10;            valueReminder.setText(timeFormat.format(selectedReminderMillis));&#10;        } else {&#10;            valueReminder.setText(&quot;Không&quot;);&#10;        }&#10;&#10;        valueRepeat.setText(selectedRecurrenceRule != null ? selectedRecurrenceRule.getPattern() : &quot;Không&quot;);&#10;    }&#10;&#10;    private void showTimePicker(boolean isDueTime) {&#10;        // Get current time or existing selected time&#10;        Calendar currentCal = Calendar.getInstance();&#10;        int hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;        int minute = currentCal.get(Calendar.MINUTE);&#10;&#10;        // If editing existing time, use that value&#10;        if (isDueTime &amp;&amp; selectedTimeMillis != null) {&#10;            currentCal.setTimeInMillis(selectedTimeMillis);&#10;            hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = currentCal.get(Calendar.MINUTE);&#10;        } else if (!isDueTime &amp;&amp; selectedReminderMillis != null) {&#10;            currentCal.setTimeInMillis(selectedReminderMillis);&#10;            hour = currentCal.get(Calendar.HOUR_OF_DAY);&#10;            minute = currentCal.get(Calendar.MINUTE);&#10;        }&#10;&#10;        // Use MaterialTimePicker (like in Lich package)&#10;        String title = isDueTime ? &quot;Đặt giờ deadline&quot; : &quot;Đặt giờ nhắc nhở&quot;;&#10;&#10;        com.google.android.material.timepicker.MaterialTimePicker picker =&#10;                new com.google.android.material.timepicker.MaterialTimePicker.Builder()&#10;                .setTimeFormat(com.google.android.material.timepicker.TimeFormat.CLOCK_24H)&#10;                .setHour(hour)&#10;                .setMinute(minute)&#10;                .setTitleText(title)&#10;                .setInputMode(com.google.android.material.timepicker.MaterialTimePicker.INPUT_MODE_CLOCK)&#10;                .build();&#10;&#10;        picker.addOnPositiveButtonClickListener(v -&gt; {&#10;            int h = picker.getHour();&#10;            int m = picker.getMinute();&#10;&#10;            // Create time calendar&#10;            Calendar sel = Calendar.getInstance();&#10;            sel.set(Calendar.HOUR_OF_DAY, h);&#10;            sel.set(Calendar.MINUTE, m);&#10;            sel.set(Calendar.SECOND, 0);&#10;            sel.set(Calendar.MILLISECOND, 0);&#10;&#10;            if (isDueTime) {&#10;                selectedTimeMillis = sel.getTimeInMillis();&#10;                valueTime.setText(timeFormat.format(selectedTimeMillis));&#10;            } else {&#10;                selectedReminderMillis = sel.getTimeInMillis();&#10;                valueReminder.setText(timeFormat.format(selectedReminderMillis));&#10;            }&#10;        });&#10;&#10;        picker.show(getParentFragmentManager(), isDueTime ? &quot;TimePickerDue&quot; : &quot;TimePickerReminder&quot;);&#10;    }&#10;&#10;    private void showRepeatDialog() {&#10;        RecurrenceBottomSheet bottomSheet = RecurrenceBottomSheet.newInstance(selectedRecurrenceRule);&#10;        bottomSheet.setOnRecurrenceSelectedListener(rule -&gt; {&#10;            selectedRecurrenceRule = rule;&#10;            updateUI();&#10;        });&#10;        bottomSheet.show(getParentFragmentManager(), &quot;RecurrenceBottomSheet&quot;);&#10;    }&#10;&#10;    private void updateChipSelection(View selectedChip, View... otherChips) {&#10;        // Set selected chip to blue background and white text&#10;        selectedChip.setBackgroundResource(R.drawable.bg_chip_selected);&#10;        if (selectedChip instanceof TextView) {&#10;            ((TextView) selectedChip).setTextColor(getResources().getColor(R.color.white, null));&#10;        }&#10;&#10;        // Set other chips to gray background and primary text color&#10;        for (View chip : otherChips) {&#10;            chip.setBackgroundResource(R.drawable.bg_chip_gray);&#10;            if (chip instanceof TextView) {&#10;                ((TextView) chip).setTextColor(getResources().getColor(R.color.text_primary, null));&#10;            }&#10;        }&#10;    }&#10;&#10;    private void checkAndHighlightMatchingChip(View parentView) {&#10;        if (selectedDateMillis == -1) {&#10;            return;&#10;        }&#10;&#10;        View chipToday = parentView.findViewById(R.id.chip_today);&#10;        View chipTomorrow = parentView.findViewById(R.id.chip_tomorrow);&#10;        View chip3Days = parentView.findViewById(R.id.chip_3days);&#10;        View chipSunday = parentView.findViewById(R.id.chip_sunday);&#10;        View chipNone = parentView.findViewById(R.id.chip_none);&#10;&#10;        // Get selected date (reset time to compare only dates)&#10;        Calendar selectedCal = Calendar.getInstance();&#10;        selectedCal.setTimeInMillis(selectedDateMillis);&#10;        selectedCal.set(Calendar.HOUR_OF_DAY, 0);&#10;        selectedCal.set(Calendar.MINUTE, 0);&#10;        selectedCal.set(Calendar.SECOND, 0);&#10;        selectedCal.set(Calendar.MILLISECOND, 0);&#10;&#10;        // Check today&#10;        Calendar today = Calendar.getInstance();&#10;        today.set(Calendar.HOUR_OF_DAY, 0);&#10;        today.set(Calendar.MINUTE, 0);&#10;        today.set(Calendar.SECOND, 0);&#10;        today.set(Calendar.MILLISECOND, 0);&#10;&#10;        if (isSameDay(selectedCal, today)) {&#10;            updateChipSelection(chipToday, chipNone, chipTomorrow, chip3Days, chipSunday);&#10;            return;&#10;        }&#10;&#10;        // Check tomorrow&#10;        Calendar tomorrow = (Calendar) today.clone();&#10;        tomorrow.add(Calendar.DAY_OF_YEAR, 1);&#10;&#10;        if (isSameDay(selectedCal, tomorrow)) {&#10;            updateChipSelection(chipTomorrow, chipNone, chipToday, chip3Days, chipSunday);&#10;            return;&#10;        }&#10;&#10;        // Check 3 days later&#10;        Calendar threeDays = (Calendar) today.clone();&#10;        threeDays.add(Calendar.DAY_OF_YEAR, 3);&#10;&#10;        if (isSameDay(selectedCal, threeDays)) {&#10;            updateChipSelection(chip3Days, chipNone, chipToday, chipTomorrow, chipSunday);&#10;            return;&#10;        }&#10;&#10;        // Check next Sunday&#10;        Calendar nextSunday = (Calendar) today.clone();&#10;        while (nextSunday.get(Calendar.DAY_OF_WEEK) != Calendar.SUNDAY) {&#10;            nextSunday.add(Calendar.DAY_OF_YEAR, 1);&#10;        }&#10;&#10;        if (isSameDay(selectedCal, nextSunday)) {&#10;            updateChipSelection(chipSunday, chipNone, chipToday, chipTomorrow, chip3Days);&#10;            return;&#10;        }&#10;&#10;        // If no match, don't highlight any chip (keep current state or highlight none)&#10;        // Reset all chips to gray&#10;        updateChipSelection(chipNone, chipToday, chipTomorrow, chip3Days, chipSunday);&#10;    }&#10;&#10;    private boolean isSameDay(Calendar cal1, Calendar cal2) {&#10;        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &amp;&amp;&#10;               cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/todolist/utils/NotificationHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/todolist/utils/NotificationHelper.java" />
              <option name="originalContent" value="package com.example.todolist.utils;&#10;&#10;import android.app.NotificationChannel;&#10;import android.app.NotificationManager;&#10;import android.app.PendingIntent;&#10;import android.content.Context;&#10;import android.content.Intent;&#10;import android.os.Build;&#10;&#10;import androidx.core.app.NotificationCompat;&#10;&#10;import com.example.todolist.R;&#10;import com.example.todolist.Ui.activity.MainActivity;&#10;&#10;public class NotificationHelper {&#10;&#10;    private static final String CHANNEL_ID = &quot;task_reminder_channel&quot;;&#10;    private static final String CHANNEL_NAME = &quot;Task Reminders&quot;;&#10;    private static final String CHANNEL_DESC = &quot;Notifications for task reminders&quot;;&#10;&#10;    /**&#10;     * Create notification channel (required for Android O and above)&#10;     */&#10;    public static void createNotificationChannel(Context context) {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            NotificationChannel channel = new NotificationChannel(&#10;                    CHANNEL_ID,&#10;                    CHANNEL_NAME,&#10;                    NotificationManager.IMPORTANCE_HIGH&#10;            );&#10;            channel.setDescription(CHANNEL_DESC);&#10;            channel.enableVibration(true);&#10;            channel.enableLights(true);&#10;&#10;            NotificationManager manager = context.getSystemService(NotificationManager.class);&#10;            if (manager != null) {&#10;                manager.createNotificationChannel(channel);&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Show notification for task reminder&#10;     */&#10;    public static void showTaskReminder(Context context, long taskId, String taskTitle, String taskDescription) {&#10;        // Check if we have permission to post notifications (Android 13+)&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            if (context.checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS)&#10;                    != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                android.util.Log.w(&quot;NotificationHelper&quot;, &quot;POST_NOTIFICATIONS permission not granted&quot;);&#10;                return;&#10;            }&#10;        }&#10;&#10;        NotificationManager notificationManager =&#10;                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#10;&#10;        if (notificationManager == null) {&#10;            return;&#10;        }&#10;&#10;        // Create intent to open app when notification is clicked&#10;        Intent intent = new Intent(context, MainActivity.class);&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#10;        intent.putExtra(&quot;task_id&quot;, taskId);&#10;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#10;                context,&#10;                (int) taskId,&#10;                intent,&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#10;        );&#10;&#10;        // Build notification&#10;        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)&#10;                .setSmallIcon(R.drawable.ic_bell)&#10;                .setContentTitle(taskTitle)&#10;                .setContentText(taskDescription.isEmpty() ? &quot;Đã đến giờ làm việc!&quot; : taskDescription)&#10;                .setPriority(NotificationCompat.PRIORITY_HIGH)&#10;                .setCategory(NotificationCompat.CATEGORY_REMINDER)&#10;                .setAutoCancel(true)&#10;                .setContentIntent(pendingIntent)&#10;                .setVibrate(new long[]{0, 500, 250, 500});&#10;&#10;        // Show notification&#10;        notificationManager.notify((int) taskId, builder.build());&#10;    }&#10;&#10;    /**&#10;     * Cancel a scheduled notification&#10;     */&#10;    public static void cancelNotification(Context context, int notificationId) {&#10;        NotificationManager notificationManager =&#10;                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#10;&#10;        if (notificationManager != null) {&#10;            notificationManager.cancel(notificationId);&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.todolist.utils;&#13;&#10;&#13;&#10;import android.app.NotificationChannel;&#13;&#10;import android.app.NotificationManager;&#13;&#10;import android.app.PendingIntent;&#13;&#10;import android.content.Context;&#13;&#10;import android.content.Intent;&#13;&#10;import android.os.Build;&#13;&#10;&#13;&#10;import androidx.core.app.NotificationCompat;&#13;&#10;&#13;&#10;import com.example.todolist.R;&#13;&#10;import com.example.todolist.Ui.activity.MainActivity;&#13;&#10;&#13;&#10;public class NotificationHelper {&#13;&#10;&#13;&#10;    private static final String CHANNEL_ID = &quot;task_reminder_channel&quot;;&#13;&#10;    private static final String CHANNEL_NAME = &quot;Task Reminders&quot;;&#13;&#10;    private static final String CHANNEL_DESC = &quot;Notifications for task reminders&quot;;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Create notification channel (required for Android O and above)&#13;&#10;     */&#13;&#10;    public static void createNotificationChannel(Context context) {&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#13;&#10;            NotificationChannel channel = new NotificationChannel(&#13;&#10;                    CHANNEL_ID,&#13;&#10;                    CHANNEL_NAME,&#13;&#10;                    NotificationManager.IMPORTANCE_HIGH&#13;&#10;            );&#13;&#10;            channel.setDescription(CHANNEL_DESC);&#13;&#10;            channel.enableVibration(true);&#13;&#10;            channel.enableLights(true);&#13;&#10;&#13;&#10;            NotificationManager manager = context.getSystemService(NotificationManager.class);&#13;&#10;            if (manager != null) {&#13;&#10;                manager.createNotificationChannel(channel);&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Show notification for task reminder&#13;&#10;     */&#13;&#10;    public static void showTaskReminder(Context context, long taskId, String taskTitle, String taskDescription) {&#13;&#10;        // Check if we have permission to post notifications (Android 13+)&#13;&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#13;&#10;            if (context.checkSelfPermission(android.Manifest.permission.POST_NOTIFICATIONS)&#13;&#10;                    != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#13;&#10;                android.util.Log.w(&quot;NotificationHelper&quot;, &quot;POST_NOTIFICATIONS permission not granted&quot;);&#13;&#10;                return;&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        NotificationManager notificationManager =&#13;&#10;                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#13;&#10;&#13;&#10;        if (notificationManager == null) {&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        // Create intent to open app when notification is clicked&#13;&#10;        Intent intent = new Intent(context, MainActivity.class);&#13;&#10;        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TASK);&#13;&#10;        intent.putExtra(&quot;task_id&quot;, taskId);&#13;&#10;&#13;&#10;        PendingIntent pendingIntent = PendingIntent.getActivity(&#13;&#10;                context,&#13;&#10;                (int) taskId,&#13;&#10;                intent,&#13;&#10;                PendingIntent.FLAG_UPDATE_CURRENT | PendingIntent.FLAG_IMMUTABLE&#13;&#10;        );&#13;&#10;&#13;&#10;        // Build notification&#10;        NotificationCompat.Builder builder = new NotificationCompat.Builder(context, CHANNEL_ID)&#10;                .setSmallIcon(R.drawable.ic_bell)&#10;                .setContentTitle(taskTitle)&#10;                .setContentText(taskDescription.isEmpty() ? &quot;Đã đến giờ làm việc!&quot; : taskDescription)&#13;&#10;                .setPriority(NotificationCompat.PRIORITY_HIGH)&#13;&#10;                .setCategory(NotificationCompat.CATEGORY_REMINDER)&#13;&#10;                .setAutoCancel(true)&#13;&#10;                .setContentIntent(pendingIntent)&#13;&#10;                .setVibrate(new long[]{0, 500, 250, 500});&#13;&#10;&#13;&#10;        // Show notification&#13;&#10;        notificationManager.notify((int) taskId, builder.build());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Cancel a scheduled notification&#13;&#10;     */&#13;&#10;    public static void cancelNotification(Context context, int notificationId) {&#13;&#10;        NotificationManager notificationManager =&#13;&#10;                (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);&#13;&#10;&#13;&#10;        if (notificationManager != null) {&#13;&#10;            notificationManager.cancel(notificationId);&#13;&#10;        }&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>